#!/usr/bin/env bash
# shellcheck disable=SC1117,SC2015,SC2028,SC2034,SC2119,SC2120,SC2154,SC2181,SC2254

# KAOSv is bash lib for SysV init scripts.
#
# This lib can be used as replacement for default /etc/init.d/functions lib.

if [[ "$BASH" == "/bin/sh" ]] ; then
  bash "$0" "$@"
  exit $?
fi

########################################################################################

if [[ -n "${SCRIPT_DEBUG}" ]] ; then
  set -x
fi

###############################################################################

# Current version of KAOSv
KV_VERSION="2.16.1"

###############################################################################

# Code for reset prev color codes
NORM=0
# Code for bold text
BOLD=1
# Code for underline text
UNLN=4
# Code for red color
RED=31
# Code for green color
GREEN=32
# Code for yellow color
YELLOW=33
BROWN=33
# Code for blue color
BLUE=34
# Code for magenta color
MAG=35
# Code for cyan color
CYAN=36
# Code for light grey color
GREY=37
# Code for dark grey color
DARK=90

CL_NORM="\e[0m"
CL_BOLD="\e[0;${BOLD};49m"
CL_UNLN="\e[0;${UNLN};49m"
CL_RED="\e[0;${RED};49m"
CL_GREEN="\e[0;${GREEN};49m"
CL_YELLOW="\e[0;${YELLOW};49m"
CL_BROWN="\e[0;${YELLOW};49m"
CL_BLUE="\e[0;${BLUE};49m"
CL_MAG="\e[0;${MAG};49m"
CL_CYAN="\e[0;${CYAN};49m"
CL_GREY="\e[0;${GREY};49m"
CL_DARK="\e[0;${DARK};49m"
CL_BL_RED="\e[1;${RED};49m"
CL_BL_GREEN="\e[1;${GREEN};49m"
CL_BL_YELLOW="\e[1;${YELLOW};49m"
CL_BL_BROWN="\e[1;${YELLOW};49m"
CL_BL_BLUE="\e[1;${BLUE};49m"
CL_BL_MAG="\e[1;${MAG};49m"
CL_BL_CYAN="\e[1;${CYAN};49m"
CL_BL_GREY="\e[1;${GREY};49m"
CL_UL_RED="\e[4;${RED};49m"
CL_UL_GREEN="\e[4;${GREEN};49m"
CL_UL_YELLOW="\e[4;${YELLOW};49m"
CL_UL_BROWN="\e[4;${YELLOW};49m"
CL_UL_BLUE="\e[4;${BLUE};49m"
CL_UL_MAG="\e[4;${MAG};49m"
CL_UL_CYAN="\e[4;${CYAN};49m"
CL_UL_GREY="\e[4;${GREY};49m"
CL_BG_RED="\e[7;${RED};49m"
CL_BG_GREEN="\e[7;${GREEN};49m"
CL_BG_YELLOW="\e[7;${YELLOW};49m"
CL_BG_BROWN="\e[7;${YELLOW};49m"
CL_BG_BLUE="\e[7;${BLUE};49m"
CL_BG_MAG="\e[7;${MAG};49m"
CL_BG_CYAN="\e[7;${CYAN};49m"
CL_BG_GREY="\e[7;${GREY};49m"

###############################################################################

umask 022

export PATH="/sbin:/usr/sbin:/bin:/usr/bin"

###############################################################################

# Current user id (Number)
USER_ID=$(id -u)

# Status code for working service
STATUS_RUNNING=1
# Status code for stopped service
STATUS_STOPPED=2
# Status code for broken service
STATUS_BROKEN=3
# Status code for a situation when service is stopped, but PID file is exist
STATUS_DEAD_WITH_PID=4
# Status code for a situation when service is stopped, but lock file is exist
STATUS_DEAD_WITH_LOCK=5
# Status code for a situation when service is running, but PID file doesn't exist
STATUS_NO_PID=6
# Status code for a situation when service is running, but lock file doesn't exist
STATUS_NO_LOCK=7

STATUS_WORKS=1

# Status for an action performed without errors
ACTION_OK=0
# Status for an action with some errors
ACTION_ERROR=1
# Status for an action which was forced
ACTION_FORCED=2

# Code for HUP signal
SIGNAL_HUP=1
# Code for INT signal
SIGNAL_INT=2
# Code for QUIT signal
SIGNAL_QUIT=3
# Code for ILL signal
SIGNAL_ILL=4
# Code for TRAP signal
SIGNAL_TRAP=5
# Code for ABRT signal
SIGNAL_ABRT=6
# Code for BUS signal
SIGNAL_BUS=7
# Code for FPE signal
SIGNAL_FPE=8
# Code for KILL signal
SIGNAL_KILL=9
# Code for USR1 signal
SIGNAL_USR1=10
# Code for SEGV signal
SIGNAL_SEGV=11
# Code for USR2 signal
SIGNAL_USR2=12
# Code for PIPE signal
SIGNAL_PIPE=13
# Code for ALRM signal
SIGNAL_ALRM=14
# Code for TERM signal
SIGNAL_TERM=15
# Code for STKFLT signal
SIGNAL_STKFLT=16
# Code for CHLD signal
SIGNAL_CHLD=17
# Code for CONT signal
SIGNAL_CONT=18
# Code for STOP signal
SIGNAL_STOP=19
# Code for TSTP signal
SIGNAL_TSTP=20
# Code for TTIN signal
SIGNAL_TTIN=21
# Code for TTOU signal
SIGNAL_TTOU=22
# Code for URG signal
SIGNAL_URG=23
# Code for XCPU signal
SIGNAL_XCPU=24
# Code for XFSZ signal
SIGNAL_XFSZ=25
# Code for VTALRM signal
SIGNAL_VTALRM=26
# Code for PROF signal
SIGNAL_PROF=27
# Code for WINCH signal
SIGNAL_WINCH=28
# Code for IO signal
SIGNAL_IO=29
# Code for PWR signal
SIGNAL_PWR=30
# Code for SYS signal
SIGNAL_SYS=31

# This constant can be used as argument in kv.setOOMScoreAdj for disabling OOM Killer
OOM_DISABLE="-1000"

HANDLER_PRE="pre"
HANDLER_POST="post"

SYSCONFIG_DIR="/etc/sysconfig"

HELP_SEPARATOR_LENGTH=4

# -
# Template for temorary data
TMP_TEMPLATE="/tmp/kaosv.XXXXXXXX"

# -
# Path to cron dir
CRON_DIR="/etc/cron.d"

# -
# Path to supervisor script
SUPERVISOR="/usr/local/share/kaosv/supervisor"

###############################################################################

kv_comm=()

declare -A kv_desc
declare -A kv_func
declare -A kv_handler
declare -A kv_handler_pre
declare -A kv_handler_post
declare -A kv_insec
declare -A kv_alias
declare -A kv_args
declare -A kv_dout
declare -A kv

# Program name used as the base for help/paths/files generation (String)
kv[prog_name]=""

# Path to lock file (String)
kv[lock_file]=""

# Path to PID file (String)
kv[pid_file]=""

# Service user (String)
kv[user]=""

# Service dir (String)
kv[dir]=""

# Enable/disable colored output (Boolean)
kv[use_colors]=true

# Automatically create PID file while service demonization (Boolean)
kv[auto_pid]=true

# Automatically create lock file while service demonization (Boolean)
kv[auto_lock]=true

# Automatically generate help command content (Boolean)
kv[auto_info]=true

# Automatically log all actions (start/stop/restart/etc...) (Boolean)
kv[auto_actions_log]=""

# Automatically search PID if PID file doesn't exist (Boolean)
kv[auto_pid_search]=true

# Time in seconds for service start (Number)
kv[delay_start]=15

# Time in seconds for service stop (Number)
kv[delay_stop]=30

# Delay between start and stop (Number)
kv[delay_restart]=0

# Path to PID dir (String)
kv[pid_dir]=/var/run

# Path to lock dir (String)
kv[lock_dir]=/var/lock/subsys

# Path to log file (String)
kv[log]=""

# Core limit (Number)
kv[core_limit]=0

# File soft/hard limit (String)
kv[file_limit]=""

# Processes soft/hard limit (String)
kv[proc_limit]=""

# Nice level (Number)
kv[nice]=""

# io nice prefs (String)
kv[ionice]=""

# OOM Score adjust (Number)
kv[oom_adj]=""

# Use supervisor feature (Boolean)
kv[supervisor]=""

# Script name (String)
kv[script]=""

# Real user name (search real user name over sudo) (String)
kv[real_user]=""

# Temporary file for service output (can be only set to /dev/null) (String)
kv[output]=""

###############################################################################

kv_pid="" # PID cache

###############################################################################

# Start command processing
#
# *: All arguments passed to service script
#
# Code: No
# Echo: No
#
# Example:
# kv.go $@
kv.go() {
  if ! kvIsColorsSupported ; then
    kv.disableColors
  fi

  kvFindExecInfo
  kvCheckExec

  [[ $# -eq 0 || "$1" == "help" ]] && kvUsage && kv.exit $ACTION_OK

  trap kv.exit SIGINT SIGTERM

  local comm="$1"

  shift

  [[ -n "${kv_alias["$comm"]}" ]] && comm="${kv_alias["$comm"]}"

  kvPrepare
  kvRegisterBasicCommands

  local comm_handler="${kv_func["$comm"]}"

  if ! kvIsFuncExist "$comm_handler" ; then
    kv.error "Can't find handler for command $comm"
    kv.exit $ACTION_ERROR
  fi

  if [[ -z ${kv_insec["$comm"]} ]] ; then
    kv.requireRoot
    kvCheckPaths
  fi

  if [[ "$comm" != "status" ]] ; then
    kvCheck
    kvMkOutput
  fi

  if [[ -n "${kv[auto_actions_log]}" ]] ; then
    kv.log "${kv[real_user]} executed command $comm"
  fi

  $comm_handler "$@"

  kv.exit $?
}

###############################################################################

# Check required version of kaosv
#
# 1: Version (String)
#
# Code: No
# Echo: No
#
# Example:
# kv.require "2.7"
kv.require() {
  [[ $# -eq 0 ]] && return

  # shellcheck disable=SC2206
  local cur_ver=(${KV_VERSION//./ })

  # shellcheck disable=SC2206
  local req_ver=(${1//./ })

  for i in $(seq 0 2) ; do
    if [[ "${req_ver[$i]}" == "" ]] ; then
      return
    fi

    if [[ ${req_ver[$i]} -gt ${cur_ver[$i]} ]] ; then
      kv.error "Init script requires kaosv $1 or higher"
      kv.exit $ACTION_ERROR
    fi
  done
}

# Add command
#
# 1: Command name (String)
# 2: Command description (String)
# 3: Handler function name (String)
# 4: Do not require root for execute (Boolean) [Optional]
#
# Code: No
# Echo: No
#
# Example:
# kv.AddCommand "check" "Check config value" "myCheckFunc" true
# kv.AddCommand "kill" "Kill connections" "myKillFunc"
kv.addCommand() {
  local comm="$1"
  local desc="$2"
  local func="$3"
  local insecure="$4"

  kv_comm+=("$comm")

  kv_desc["$comm"]="$desc"
  kv_func["$comm"]="$func"
  kv_insec["$comm"]="$insecure"
}

# Add handler for start/stop/restart/status command
#
# 1: Command name (String)
# 2: Handler (String)
# 3: Type of handler (pre/post/default) (String)
#
# Code: No
# Echo: No
kv.addHandler() {
  local comm="$1"
  local handler="$2"
  local htype="$3"

  case $htype in
    $HANDLER_PRE)  kv_handler_pre["$comm"]="$handler" ;;
    $HANDLER_POST) kv_handler_post["$comm"]="$handler" ;;
    *)             kv_handler["$comm"]="$handler" ;;
  esac
}

# Add alias for command
#
# 1: Command name (String)
# 2: Alias name (String)
#
# Code: No
# Echo: No
#
# Example:
# kv.addCommandAlias "test" "check"
kv.addCommandAlias() {
  local comm="$1"
  local als="$2"

  kv_alias["$als"]="$comm"
}

# Add some arguments supported by command
#
# 1: Command (String)
# *: Vars (String)
#
# Code: No
# Echo: No
#
# Example:
# kv.addCommandArgs "stop" "force"
kv.addCommandArgs() {
  local comm="$1"

  shift

  local arg args

  for arg in "$@" ; do
    vars="$args $arg"
  done

  kv_args["$comm"]="${vars:1:9999}"
}

# -
# Alias for kv.addCommandArgs for compatibility with
# earlier versions
kv.addCommandVars() {
  kv.addCommandArgs "$@"
  return $?
}

# Disable automatic output redirection
#
# 1: Handler name (String)
# 2: Type of handler (pre/post/default) (String)
#
# Code: No
# Echo: No
kv.disableOutputRedirect() {
  local handler="$1"
  local htype="$2"

  case $handler in
    "start" | "stop" | "restart") ;;
    *) kv.error "Handler \"$handler\" is can't be used in kv.disableOutputRedirect" ; kv.exit $ACTION_ERROR ;;
  esac

  if [[ -n "$htype" ]] ; then
    kv_dout["${handler}_${htype}"]=true
  else
    kv_dout["$handler"]=true
  fi
}

# Eval values from sysconfig
#
# 1: Name of sysconfig file (String) [Optional]
#
# Code: No
# Echo: No
kv.readSysconfig() {
  local conf strict

  conf="${1:-${kv[prog_name]}}"
  strict="$2"

  if [[ -n "$strict" ]] ; then
    [[ -z "$conf" ]] && kv.error "Can't read sysconfig file - config name is not defined" && return 1

    [[ ! -f "$SYSCONFIG_DIR/$conf" ]] && kv.error "Can't read sysconfig file - file <$SYSCONFIG_DIR/$conf> doesn't exist" && return 1
    [[ ! -r "$SYSCONFIG_DIR/$conf" ]] && kv.error "Can't read sysconfig file - file <$SYSCONFIG_DIR/$conf> is not readable" && return 1
  fi

  [[ ! -r $SYSCONFIG_DIR/$conf ]] && return 0

  local ar oi

  ar=$(stat -c "%A" "$SYSCONFIG_DIR/$conf")
  oi=$(stat -c "%U" "$SYSCONFIG_DIR/$conf")

  if [[ "${ar:8:1}" != "-" ]] ; then
    kv.error "Can't read sysconfig file - unsecure access rights" && return 1
  fi

  if [[ "$oi" != "root" ]] ; then
    kv.error "Can't read sysconfig file - owner is not root" && return 1
  fi

  # shellcheck disable=SC1090
  source "$SYSCONFIG_DIR/$conf"
}

# Exec command
#
# *: Command (String)
#
# Code: Exit code (Boolean)
# Echo: No
#
# Example:
# local status=$(kv.run "/bin/echo" "1234" "ABCD")
#
# if [[ $status -eq 0 ]] ; then
#   return $ACTION_OK
# else
#   return $ACTION_ERROR
# fi
kv.run() {
  [[ $# -eq 0 ]] && kv.log "You can't execute kv.run without arguments" && return 1

  kv.runAs "${kv[user]:-root}" "$@"

  return $?
}

# Exec command as some user
#
# 1: User (String)
# *: Command
#
# Code: Exit code (Boolean)
# Echo: No
#
# Example:
# kv.runAs "someuser" "/bin/echo" "1234" "ABCD"
#
# if [[ $? -eq 0 ]] ; then
#   return $ACTION_OK
# else
#   return $ACTION_ERROR
# fi
kv.runAs() {
  [[ $# -le 1 ]] && kv.log "You can't execute kv.runAs without arguments" && return 1

  local cmd_user="$1"

  shift

  if [[ -n "$cmd_user" ]] ; then
    if ! kv.hasUser "$cmd_user" ; then
      echo "Can't execute command - user $cmd_user doesn't exist on the system" >> "${kv[output]}"
      return $ACTION_ERROR
    fi
  fi

  local args="$*"
  local cl_limit cl_nice tmp_limit_conf status

  cl_nice=$(kvGetNicesCmd)

  if [[ "$cmd_user" == "root" ]] ; then
    cl_limit=$(kvGetLimitsCmd)
    $cl_nice /bin/bash -c "$cl_limit; $args" &>> "${kv[output]}"
  else
    tmp_limit_conf=$(kvMakeTempLimitsConfig)
    $cl_nice runuser -s /bin/bash "$cmd_user" -c "$args" &>> "${kv[output]}"
  fi

  status=$?

  # Remove temporary limits config if exist
  if [[ -n "$tmp_limit_conf" ]] ; then
    rm -f "$tmp_limit_conf" &> /dev/null
  fi

  return $status
}

# Daemonize process
#
# 1: Binary (String)
# *: Command arguments
#
# Code: Return code (Boolean)
# Echo: No
#
# Example:
# kv.daemonize "/usr/bin/daemon" "-d" "-p 80" "-v"
#
# if [[ $? -eq 0 ]] ; then
#   return $ACTION_OK
# else
#   return $ACTION_ERROR
# fi
kv.daemonize() {
  [[ $# -eq 0 ]] && kv.log "You can't execute kv.daemonize without arguments" && return 1

  local bin="$1"

  [[ "${bin:0:1}" != "/" || ! -x $bin ]] && kv.log "First argument in kv.daemonize must be absolute path to executable file" && return 1

  local args=""

  [[ -n "${kv[auto_pid]}" ]] && args="$args -p ${kv[pid_file]}"
  [[ -n "${kv[user]}" ]] && args="$args -u ${kv[user]}"
  [[ -n "${kv[dir]}" ]] && args="$args -c ${kv[dir]}"
  [[ -n "${kv[log]}" ]] && args="$args -a -o ${kv[log]} -e ${kv[log]}"

  args="$args $*"

  local cl_limit cl_nice

  cl_limit=$(kvGetLimitsCmd)
  cl_nice=$(kvGetNicesCmd)

  /bin/bash -c "$cl_limit; $cl_nice daemonize $args" &>> "${kv[output]}"

  return $?
}

# Execute default start handler
#
# *: Any arguments
#
# Code: Return code (Boolean)
# Echo: No
kv.start() {
  kvStart "$@"
  return $?
}

# Execute default stop handler
#
# *: Any arguments
#
# Code: Return code (Boolean)
# Echo: No
kv.stop() {
  kvStop "$@"
  return $?
}

# Execute default restart handler
#
# *: Any arguments
#
# Code: Return code (Boolean)
# Echo: No
kv.restart() {
  kvRestart "$@"
  return $?
}

# Execute default status handler
#
# *: Any arguments
#
# Code: Return code (Boolean)
# Echo: No
kv.status() {
  kvStatus "$@"
  return $?
}

# Execute default usage handler
#
# *: Any arguments
#
# Code: Return code (Boolean)
# Echo: No
kv.usage() {
  kvUsage "$@"
  return $?
}

# Require root privileges, if user is not
# a root, exit with error status
#
# Code: No
# Echo: No
kv.requireRoot() {
  if ! kv.isRoot ; then
    kv.error "You must have root privileges to use this command"
    kv.exit $ACTION_ERROR
  fi
}

# Return 0 if service in defined status
#
# 1: Status (Number) [Optional]
#
# Code: Boolean
# Echo: No
kv.statusIs() {
  local nstatus cstatus

  nstatus="$1"
  cstatus=$(kv.getStatus)

  [[ "$cstatus" == "$nstatus" ]] && return 0 || return 1
}

# Get the status of service
#
# Code: No
# Echo: Status code (Number)
kv.getStatus() {
  local pid_file_mod boot_date pid

  if [[ -f "${kv[pid_file]}" && -r "${kv[pid_file]}" ]] ; then
    pid_file_mod=$(kvGetFileModDate "${kv[pid_file]}")
    boot_date=$(kvGetBootTimestamp)

    if [[ $boot_date -gt $pid_file_mod ]] ; then
      echo $STATUS_DEAD_WITH_PID && return
    fi

    pid=$(kv.getPID)

    [[ -z "$pid" ]] && echo $STATUS_BROKEN && return

    if kv.isProcExist "$pid" ; then
      if [[ ! -f ${kv[lock_file]} ]] ; then
        echo $STATUS_NO_LOCK && return
      else
        echo $STATUS_RUNNING && return
      fi
    else
      echo $STATUS_DEAD_WITH_PID && return
    fi
  else
    pid=$(kv.findPID)

    if [[ -n "$pid" ]] ; then
      if [[ ! -f ${kv[pid_file]} ]] ; then
        echo $STATUS_NO_PID && return
      else
        echo $STATUS_BROKEN && return
      fi
    else
      if [[ -f ${kv[lock_file]} ]] ; then
        echo $STATUS_DEAD_WITH_LOCK && return
      else
        echo $STATUS_STOPPED && return
      fi
    fi
  fi
}

# Get or find PID
#
# Code: No
# Echo: PID (Number)
#
# Example:
# local pid=$(kv.getPID)
# kv.sendSignal $pid
kv.getPID() {
  if [[ -f "${kv[pid_file]}" && -r "${kv[pid_file]}" ]] ; then
    cat "${kv[pid_file]}"
  else
    kv.findPID
  fi
}

# -
kv.getPid() {
  kv.getPID "$@"
}

# Find service PID
#
# Code: No
# Echo: PID (Number)
#
# Example:
# local pid=$(kv.findPID)
kv.findPID() {
  [[ -z "${kv[auto_pid_search]}" ]] && return

  local pkg pkg_file pid cmd_info cmd_part user

  pkg=$(rpm -qf "/etc/init.d/${kv[script]}")

  if [[ -z "$pkg" ]] ; then
    return
  fi

  for pkg_file in $(rpm -ql "$pkg") ; do
    # shellcheck disable=SC1001
    if [[ ! "$pkg_file" =~ (\/sbin\/|\/bin\/) ]] ; then
      continue
    fi

    if [[ ! -f "$pkg_file" || ! -x "$pkg_file" ]] ; then
      continue
    fi

    # shellcheck disable=SC2207
    cmd_info=($(pgrep -o -l -f "$pkg_file"))

    if [[ ${#cmd_info[@]} -eq 0 ]] ; then
      continue
    fi

    for cmd_part in "${cmd_info[@]:1}" ; do
      if [[ "$cmd_part" == "$pkg_file" ]] ; then
        pid="${cmd_info[0]}"
      fi
    done

    if [[ -z "$pid" ]] ; then
      continue
    fi

    user=$(ps --no-header -p "$pid" -o user)

    if [[ "$user" != "${kv[user]:-root}" ]] ; then
      continue
    fi

    echo "$pid"
    return
  done
}

# -
kv.findPid() {
  kv.findPID "$@"
}

# Show message about action in progress
#
# 1: Message (String)
#
# Code: No
# Echo: No
#
# Example:
# kv.showProcessMessage "Generating data"
# kv.showStatusMessage $ACTION_OK
kv.showProcessMessage() {
  kv.showm "$1: " $BOLD
}

# Show status message by status code
#
# 1: Status code (Number)
#
# Code: No
# Echo: No
#
# Example:
# kv.showProcessMessage "Generating data"
# kv.showStatusMessage $ACTION_OK
kv.showStatusMessage() {
  case $1 in
    $ACTION_OK)     kv.show "${CL_GREEN}OK${CL_NORM}" ;;
    $ACTION_ERROR)  kv.show "${CL_RED}ERROR${CL_NORM}" ;;
    $ACTION_FORCED) kv.show "${CL_YELLOW}FORCED${CL_NORM}" ;;
  esac

  return "$1"
}

# Get status of starting service
#
# 1: Path to PID file (String) [Optional]
# 2: Don't check process status (Boolean) [Optional]
#
# Code: Status (Boolean)
# Echo: No
#
# Example:
# if ! kv.getStartStatus ; then
#   kv.error "Can't start service"
# fi
kv.getStartStatus() {
  local cpid_file="${1:-${kv[pid_file]}}"
  local no_check_proc="$2"

  local i pid

  for i in $(seq 1 "${kv[delay_start]:-15}") ; do
    if [[ -f $cpid_file && -r $cpid_file ]] ; then
      [[ -n "$no_check_proc" ]] && return $ACTION_OK

      pid=$(head -1 "$cpid_file")

      if kv.isProcExist "$pid" ; then
        return $ACTION_OK
      fi
    fi

    sleep 1
  done

  return $ACTION_ERROR
}

# Get status of stopping service
#
# 1: PID (Number) [Optional]
#
# Code: Status (Boolean)
# Echo: No
#
# Example:
# if kv.getStopStatus $pid ; then
#   return $ACTION_OK
# else
#   kv.killProcess $pid
#   return $ACTION_FORCED
# fi
kv.getStopStatus() {
  local pid="${1:-$kv_pid}"

  [[ -z "$pid" ]] && return $ACTION_ERROR

  local i

  for i in $(seq 1 "${kv[delay_stop]:-30}") ; do
    if ! kv.isProcExist "$pid" ; then
      return $ACTION_OK
    fi

    sleep 1
  done

  return $ACTION_ERROR
}

# Kill service process
#
# 1: PID (Number) [Optional]
#
# Code: No
# Echo: No
kv.killProcess() {
  local pid="$1"

  [[ -z "$pid" ]] && pid=$(kv.findPID)
  [[ -z "$pid" ]] && return 1

  kill -KILL "$pid" >/dev/null 2>&1

  kv.removeLock
  kv.removePID
}

# Return 0 if process with specified PID exist
#
# 1: PID (Number)
#
# Code: Yes
# Echo: No
#
# Example:
# if kv.isProcExist 12345 ; then
#   kv.error "Process with PID 12345 doesn't exist"
# fi
kv.isProcExist() {
  [[ -d /proc/$1 ]] && return 0 || return 1
}

# Return 0 if user exists on the system
#
# 1: Username (String)
#
# Code: Yes
# Echo: No
#
# Example:
# if ! kv.hasUser "serviceuser" ; then
#   kv.error "User serviceuser doesn't exist!"
# fi
kv.hasUser() {
  if grep -q -E "^$1:" /etc/passwd ; then
    return 0
  fi

  return 1
}

# Check that port is bound (occupied by another process)
#
# 1: Port (Number)
#
# Code: Yes
# Echo: No
#
# Example:
# if kv.isBoundPort 8080 ; then
#   kv.error "Port 8080 is bound"
# fi
kv.isBoundPort() {
  [[ $# -eq 0 ]] && return 1
  [[ -n $(netstat -antu | tr -s " " | cut -f4 -d" " | sed 's/:.*:/:/g' | cut -f2 -d":" | grep -E "^$1$" | head -1) ]] && return 0 || return 1
}

# Check that service is works
#
# 1: Service name (String)
#
# Code: Yes
# Echo: No
#
# Example:
# if kv.isServiceWorks "nginx" ; then
#   kv.error "Service nginx is works"
# fi
kv.isServiceWorks() {
  local service_name="$1"

  if [[ "$service_name" == "" ]] ; then
    return 1
  fi

  /sbin/service "$service_name" status &> /dev/null

  if [[ $? -eq 0 ]] ; then
    return 0
  fi

  return 1
}

# Return 0 if specified apps installed on the system
#
# 1: Apps (List)
#
# Code: Yes
# Echo: No
#
# Example:
# if ! kv.isInstalled "java" "nc" ; then
#   kv.error "Java and netcat is not installed"
# fi
kv.isInstalled() {
  local app

  for app in "$@" ; do
    type -p "$app" &> /dev/null
    [[ $? -ne 0 ]] && return 1
  done

  return 0
}

# Send a signal to service
#
# 1: Signal (String)
# 2: PID (Number) [Optional]
#
# Code: Yes
# Echo: No
#
# Example:
# if ! kv.sendSignal $SIGNAL_QUIT ; then
#   kv.error "Can't send signal"
# fi
kv.sendSignal() {
  [[ $# -eq 0 ]] && return 1

  local signal="$1"
  local pid

  [[ -n "$2" ]] && pid="$2" || pid=$(kv.getPID)
  [[ -z "$pid" || -z "$signal" ]] && return 1

  kill "-${signal}" "$pid" >/dev/null 2>&1
}

# Set the adjustment level for the Out of memory (OOM) killer
#
# 1: Adjustment level (Number) [Optional]
# 2: PID (Number) [Optional]
#
# Code: No
# Echo: No
#
# Example:
# kv.setOOMScoreAdj "-1000" "12345"
# kv.setOOMScoreAdj "$OOM_DISABLE"
kv.setOOMScoreAdj() {
  local adj="${1:-${kv[oom_adj]}}"
  local pid="$2"

  [[ -z "$adj" ]] && return 1
  [[ -z "$pid" ]] && pid=$(kv.getPID)
  [[ -z "$pid" ]] && return 1

  if ! echo "$adj" 1> "/proc/$pid/oom_score_adj" 2>/dev/null ; then
    kv.warn "Can't set OOM score adjustment"
  fi
}

# Check SE Linux
#
# Code: Boolean
# Echo: No
kv.checkSELinux() {
  if [[ $(getenforce) == "Enforcing" ]] ; then
    kv.show ""
    kv.show "Can't start ${kv[prog_name]}. It looks like SELinux blocks port binding." $RED
    kv.show "To resolve this problem change SELinux mode to ${CL_BOLD}Permissive${CL_NORM}"
    kv.show "by ${CL_BOLD}sudo setenforce 0${CL_NORM} command or configure SELinux context."

    return $ACTION_ERROR
  fi
}

# Change file or directory owner, but DO NOT follow symlinks
#
# *: All options and arguments for chown command
#
# Code: Yes
# Echo: No
#
# Example:
# kv.chown -h root:staff myfile.txt
kv.chown() {
  # shellcheck disable=SC2124
  local object="${@: -1}"

  if [[ -h "$object" ]] ; then
    return 1
  fi

  chown "$@"

  return $?
}

# Change file or directory mode, but DO NOT follow symlinks
#
# *: All options and arguments for chmod command
#
# Code: Yes
# Echo: No
#
# Example:
# kv.chmod --silent 0644 myfile.txt
kv.chmod() {
  # shellcheck disable=SC2124
  local object="${@: -1}"

  if [[ -h "$object" ]] ; then
    return 1
  fi

  chmod "$@"

  return $?
}

###############################################################################

# Check if the user is root
#
# Code: Yes
# Echo: No
#
# Example:
# if ! kv.isRoot ; then
#   kv.error "This action require root privileges!"
# fi
kv.isRoot() {
  [[ "$USER_ID" != "0" ]] && return 1 || return 0
}

# Create lock file
#
# Code: No
# Echo: No
kv.createLock() {
  touch "${kv[lock_file]}" &> /dev/null
}

# Remove lock file
#
# Code: No
# Echo: No
kv.removeLock() {
  rm -rf "${kv[lock_file]}" &> /dev/null
}

# Return 0 if lock file exist
#
# Code: Yes
# Echo: No
#
# Example:
# if kv.hasLock ; then
#   echo "Lock file exist!"
# fi
kv.hasLock() {
  [[ -f "${kv[lock_file]}" ]] && return 1 || return 0
}

# Create PID file
#
# 1: PID (Number)
#
# Code: No
# Echo: No
#
# Example:
# kv.createPIDFile 12345
kv.createPIDFile() {
  echo "$1" 1> "${kv[pid_file]}" 2>/dev/null
}

# -
kv.createPid() {
  kv.createPIDFile "$@"
}

# Remove PID file
#
# Code: No
# Echo: No
kv.removePIDFile() {
  rm -f "${kv[pid_file]}" &> /dev/null
}

# -
kv.removePid() {
  kv.removePIDFile "$@"
}

# Exit from the script
#
# 1: Error code (Number) [Optional]
#
# Code: No
# Echo: No
#
# Example:
# kv.exit
# kv.exit 1
kv.exit() {
  kvSendOutputToLogger

  exit "${1:-0}"
}

###############################################################################

# Disable all colors in output
#
# Code: No
# Echo: No
kv.disableColors() {
  unset NORM BOLD UNLN RED GREEN YELLOW BROWN BLUE MAG CYAN GREY DARK
  unset CL_NORM CL_BOLD CL_UNLN CL_RED CL_GREEN CL_YELLOW CL_BLUE CL_MAG CL_CYAN CL_GREY CL_DARK
  unset CL_BL_RED CL_BL_GREEN CL_BL_YELLOW CL_BL_BLUE CL_BL_MAG CL_BL_CYAN CL_BL_GREY
  unset CL_UL_RED CL_UL_GREEN CL_UL_YELLOW CL_UL_BLUE CL_UL_MAG CL_UL_CYAN CL_UL_GREY
  unset CL_BG_RED CL_BG_GREEN CL_BG_YELLOW CL_BG_BLUE CL_BG_MAG CL_BG_CYAN CL_BG_GREY
  kv[use_colors]=""
}

# Print error message
#
# 1: Message (String)
#
# Code: No
# Echo: No
#
# Example:
# kv.error "My error message"
kv.error() {
  kv.show "$1" $RED 1>&2
}

# Print warning message
#
# 1: Message (String)
#
# Code: No
#
# Example:
# kv.warn "My warning message"
kv.warn() {
  kv.show "$@" $YELLOW 1>&2
}

# Show message
#
# 1: Message (String)
# 2: Color (String) [Optional]
#
# Code: No
# Echo: No
#
# Example:
# show "Signal sended"
# show "Can't do some action" $RED
kv.show() {
  if [[ -n "$2" && -n "${kv[use_colors]}" ]] ; then
    echo -e "\e[${2}m${1}\e[0m"
  else
    echo -e "$*"
  fi
}

# Show message without new line symbol
#
# 1: Message (String)
# 2: Color (String) [Optional]
#
# Code: No
# Echo: No
kv.showm() {
  if [[ -n "$2" && -n "${kv[use_colors]}" ]] ; then
    echo -e -n "\e[${2}m${1}\e[0m"
  else
    echo -e -n "$*"
  fi
}

# Show version of kaosv
#
# Code: No
# Echo: Version (String)
kv.version() {
  echo "$KV_VERSION"
}

# Restore SELinux context
#
# *: Files
#
# Code: No
# Echo: No
#
# Example:
# kv.restoreSEContext "/path/to/file"
kv.restoreSEContext() {
  local target

  for target in "$@" ; do
    [[ -x /sbin/restorecon ]] && /sbin/restorecon "$target"
  done
}

# Read property from file
#
# 1: File (String)
# 2: Property name (String)
# 3: Delimiter (String) [Optional]
#
# Code: No
# Echo: Property value (String)
#
# Example:
# local port=$(kv.readProperty "/path/to/my.conf" "port")
# local host=$(kv.readProperty "/path/to/my.conf" "host" ":")
kv.readProperty() {
  local file="$1"
  local prop="$2"
  local delm="${3:-=}"

  [[ -z "$file" || -z "$prop" ]] && echo "" && return 1

  grep -E "^([ ]{0,})${prop}" "$file" | awk "-F${delm}" '{print $2}' | sed 's/^ *//'
}

# Add message to logfile or logger
#
# 1: Message (String)
#
# Code: No
# Echo: No
#
# Example:
# kv.log "My very important message"
kv.log() {
  local message="$*"

  if [[ -n "${kv[log]}" ]] ; then
    echo "$message" 1>> "${kv[log]}" 2> /dev/null
  else
    echo "$message" | logger -i -t "${kv[prog_name]}(kaosv)"
  fi
}

###############################################################################

# -
#
# Find basic info about current script execution
#
# *: Full command
#
# Code: No
# Echo: No
kvFindExecInfo() {
  if [[ "$0" != "-bash" ]] ; then
    kv[script]=$(readlink -f "$0" | xargs -n1 basename)
  fi

  kv[real_user]=$(who -m 2>/dev/null | cut -f1 -d" ")

  if [[ -z "${kv[real_user]}" ]] ; then
    if [[ -n "$SUDO_USER" ]] ; then
      kv[real_user]="$SUDO_USER"
    else
      kv[real_user]="root"
    fi
  fi
}

# -
#
# Check how script was executed
#
# Code: No
# Echo: No
kvCheckExec() {
  if [[ -n $(printenv HOME) || -n $(printenv SHELL) ]] ; then
    kv.error "Direct script execution is forbidden. You should use 'service' utility instead."
    exit 1
  fi
}

# -
#
# Prepare script for start
#
# Code: No
# Echo: No
kvPrepare() {
  [[ -z "${kv[pid_file]}" ]] && kv[pid_file]="${kv[pid_dir]}/${kv[script]}.pid"
  [[ -z "${kv[lock_file]}" ]] && kv[lock_file]="${kv[lock_dir]}/${kv[script]}"

  kv[pid_dir]=$(dirname "${kv[pid_file]}")
  kv[lock_dir]=$(dirname "${kv[lock_file]}")
}

# -
#
# Check preferencies before start
#
# Code: No
# Echo: No
kvCheck() {
  if [[ -z "${kv[prog_name]}" ]] ; then
    kv.error "Can't execute this init script. Please define prog_name value first"
    kv.exit $ACTION_ERROR
  fi

  if ! kvIsWellPath "${kv[pid_dir]}" ; then
    kv.error "Can't execute this init script. Property \"pid_dir\" contains the wrong path (${kv[pid_dir]})"
    kv.exit $ACTION_ERROR
  fi

  if ! kvIsWellPath "${kv[lock_dir]}" ; then
    kv.error "Can't execute this init script. Property \"lock_dir\" contains the wrong path (${kv[lock_dir]})"
    kv.exit $ACTION_ERROR
  fi

  if [[ -n "${kv[output]}" ]] ; then
    if ! kvIsWellPath "${kv[output]}" ; then
      kv.error "Can't execute this init script. Property \"output\" contains the wrong path (${kv[output]})"
      kv.exit $ACTION_ERROR
    fi
  fi

  if [[ -n "${kv[dir]}" ]] ; then
    if ! kvIsWellPath "${kv[dir]}" ; then
      kv.error "Can't execute this init script. Property \"dir\" contains the wrong path (${kv[dir]})"
      kv.exit $ACTION_ERROR
    fi

    if [[ ! -d ${kv[dir]} ]] ; then
      kv.error "Can't execute this init script. Service directory <${kv[dir]}> doesn't exist"
      kv.exit $ACTION_ERROR
    fi
  fi

  if [[ -n "${kv[user]}" ]] ; then
    if ! kv.hasUser "${kv[user]}" ; then
      kv.error "User <${kv[user]}> doesn't exist"
      kv.exit $ACTION_ERROR
    fi
  fi

  if [[ -n "${kv[log]}" ]] ; then
    local log_dir

    log_dir=$(dirname "${kv[log]}")

    if ! kvIsWellPath "$log_dir" ; then
      kv.error "Can't execute this init script. Property log contains wrong path (${kv[log]})."
      kv.exit $ACTION_ERROR
    fi

    if [[ ! -d "$log_dir" ]] ; then
      kv.error "Log file directory <$log_dir> doesn't exist"
      kv.exit $ACTION_ERROR
    fi

    if [[ -f "${kv[log]}" && ! -w "${kv[log]}" ]] ; then
      kv.error "Log file is not writable"
      kv.exit $ACTION_ERROR
    fi
  fi

  if ! kvIsWellPath "${kv[pid_dir]}" ; then
    kv.error "Can't use PID dir <${kv[pid_dir]}>"
    kv.exit $ACTION_ERROR
  fi

  if ! kvIsWellPath "${kv[lock_dir]}" ; then
    kv.error "Can't use lock dir <${kv[lock_dir]}>"
    kv.exit $ACTION_ERROR
  fi
}

# -
#
# Register basic command (start, stop, restart, status, help)
#
# Code: No
# Echo: No
kvRegisterBasicCommands() {
  [[ -z "${kv_func[start]}" ]]   && kv_func[start]="kvStart"
  [[ -z "${kv_func[stop]}" ]]    && kv_func[stop]="kvStop"
  [[ -z "${kv_func[restart]}" ]] && kv_func[restart]="kvRestart"
  [[ -z "${kv_func[status]}" ]]  && kv_func[status]="kvStatus" && kv_insec[status]=true
  [[ -z "${kv_func[help]}" ]]    && kv_func[help]="kvUsage"
}

# -
#
# Method return ulimit command for setting limits
#
# Code: No
# Echo: Command (String)
kvGetLimitsCmd() {
  local result nproc nofile s_nproc s_nofile h_nproc h_nofile

  nproc="${kv[proc_limit]}"
  nofile="${kv[file_limit]}"

  if [[ -n "$nproc" ]] ; then
    s_nproc="${nproc%:*}"
    h_nproc="${nproc#*:}"
  fi

  if [[ -n "$nofile" ]] ; then
    s_nofile="${nofile%:*}"
    h_nofile="${nofile#*:}"
  fi

  result="ulimit -S -c ${kv[core_limit]} &>/dev/null"

  if [[ -n "${h_nproc}${s_nproc}" ]] ; then
    [[ -n "$h_nproc" ]] && result="$result; ulimit -H -u $h_nproc &>/dev/null"
    [[ -n "$s_nproc" ]] && result="$result; ulimit -S -u $s_nproc &>/dev/null"
  fi

  if [[ -n "${h_nofile}${s_nofile}" ]] ; then
    [[ -n "$h_nofile" ]] && result="$result; ulimit -H -n $h_nofile &>/dev/null"
    [[ -n "$s_nofile" ]] && result="$result; ulimit -S -n $s_nofile &>/dev/null"
  fi

  echo "$result"
}

# -
#
# Create temporary limits config for setting limits
#
# Code: No
# Echo: Path to config (String)
kvMakeTempLimitsConfig() {
  local result nproc nofile s_nproc s_nofile h_nproc h_nofile np nf

  nproc="${kv[proc_limit]}"
  nofile="${kv[file_limit]}"

  if [[ -n "$nproc" ]] ; then
    s_nproc="${nproc%:*}"
    h_nproc="${nproc#*:}"
  fi

  if [[ -n "$nofile" ]] ; then
    s_nofile="${nofile%:*}"
    h_nofile="${nofile#*:}"
  fi

  np=$(kvGetUserLimit "${kv[user]}" "nproc")
  nf=$(kvGetUserLimit "${kv[user]}" "nofile")

  # Unset values if limits already set through config
  [[ -n "${np%:*}" ]] && s_nproc=""
  [[ -n "${np#*:}" ]] && h_nproc=""
  [[ -n "${nf%:*}" ]] && s_nofile=""
  [[ -n "${nf#*:}" ]] && h_nofile=""

  result="/etc/security/limits.d/99-${kv[script]}-temporary.conf"

  echo "# TEMPORARY LIMITS CONFIG GENERATED BY KAOSV\n" > "$result"

  [[ -n "$s_nproc" ]]  && echo "${kv[user]} soft nproc ${s_nproc}" >> "$result"
  [[ -n "$h_nproc" ]]  && echo "${kv[user]} hard nproc ${h_nproc}" >> "$result"
  [[ -n "$s_nofile" ]] && echo "${kv[user]} soft nofile ${s_nofile}" >> "$result"
  [[ -n "$h_nofile" ]] && echo "${kv[user]} hard nofile ${h_nofile}" >> "$result"

  echo "" 1>> "$result" 2> /dev/null

  echo "$result"
}

# -
#
# Method return soft and hard limits
#
# Code: No
# Echo: Soft and hard limit (String)
kvGetUserLimit() {
  local user="$1"
  local item="$2"

  local rec reca soft hard soft_wc hard_wc
  local lm_user lm_type lm_item lm_value

  while read -r rec ; do
    read -r -a reca <<< "$rec"

    lm_user="${reca[0]}"
    lm_type="${reca[1]}"
    lm_item="${reca[2]}"
    lm_value="${reca[3]}"

    if [[ "$lm_item" == "$item" ]] ; then
      if [[ "$lm_user" == "*" ]] ; then
        if [[ "$lm_type" == "soft" ]] ; then
          soft_wc="$lm_value"
        elif [[ "$lm_type" == "hard" ]] ; then
          hard_wc="$lm_value"
        fi
      elif [[ "$lm_user" == "$user" ]] ; then
        if [[ "$lm_type" == "soft" ]] ; then
          soft="$lm_value"
        elif [[ "$lm_type" == "hard" ]] ; then
          hard="$lm_value"
        fi
      fi
    fi
  done < <(kvListLimits)

  soft=${soft:-$soft_wc}
  hard=${hard:-$hard_wc}

  [[ -n "$soft" || -n "$hard" ]] && echo "$soft:$hard"
}

# -
#
# Read all limits
#
# Code: No
# Echo: All system limits (String)
kvListLimits() {
  local limit_confs=""

  limit_confs=$(find /etc/security/limits.d -type f -name "*.conf" | sort | tr "\n" " ")
  limit_confs="/etc/security/limits.conf ${limit_confs}"

  grep -v "^#" "$limit_confs" 2>/dev/null | sed '/^\s*$/d' | tr "\t" " " | tr -s " "
}

# -
#
# Method return nice command
#
# Code: No
# Echo: Command (String)
kvGetNicesCmd() {
  local result nlevel nclass nclassdata ion

  if [[ -n "${kv[nice]}" ]] ; then
    result="nice -n ${kv[nice]}"
  fi

  if [[ -n "${kv[ionice]}" ]] ; then
    ion="${kv[ionice]}"

    nclass="${ion%:*}"
    nclassdata="${ion#*:}"

    result="$result ionice"

    [[ -n "$nclass" ]] && result="$result -c $nclass"
    [[ -n "$nclassdata" ]] && result="$result -n $nclassdata"

  fi

  echo "$result"
}

# -
#
# Method checks used paths and exits if some path is not safety
#
# Code: No
# Echo: No
kvCheckPaths() {
  if [[ ! -e ${kv[pid_dir]} ]] ; then
    if kv.isRoot ; then
      mkdir -p "${kv[pid_dir]}" &> /dev/null
    fi
  fi

  if [[ "${kv[pid_dir]}" != "/var/run" && "${kv[pid_dir]}" != "/var/run/" ]] ; then
    if [[ -n "${kv[user]}" && "${kv[user]}" != $(kvGetOwner "${kv[pid_dir]}") ]] ; then
      if kv.isRoot ; then
        if ! kv.hasUser "${kv[user]}" ; then
          kv.error "Can't change owner for PID directory <${kv[pid_dir]}> - user <${kv[user]}> not exist on the system"
          kv.exit $ACTION_ERROR
        fi

        chown "${kv[user]}" "${kv[pid_dir]}"
      fi
    fi
  fi

  if [[ ! -e "${kv[lock_dir]}" ]] ; then
    if kv.isRoot ; then
      mkdir -p "${kv[lock_dir]}" &> /dev/null
    fi
  fi

  if [[ ! -w "${kv[lock_dir]}" ]] ; then
    kv.error "Lock dir <${kv[lock_dir]}> is not writable"
    kv.exit $ACTION_ERROR
  fi
   if [[ ! -w "${kv[pid_dir]}" ]] ; then
    kv.error "PID dir <${kv[pid_dir]}> is not writable"
    kv.exit $ACTION_ERROR
  fi
}

# -
#
# Method return owner of the file
#
# 1: File (String)
#
# Code: No
# Echo: Owner name (String)
kvGetOwner() {
  [[ ! -f "$1" ]] && return
  stat -c "%U" "$1"
}

# -
#
# The method checks what given path is well formatted and safe
#
# 1: Path (String)
#
# Code: Yes
# Echo: No
kvIsWellPath() {
  case $1 in
    "")         return 1 ;;
    "/")        return 1 ;;
    "/home")    return 1 ;;
    "/home/")   return 1 ;;
    "/usr")     return 1 ;;
    "/usr/")    return 1 ;;
    "/var")     return 1 ;;
    "/var/")    return 1 ;;
  esac

  [[ $1 =~ ^/bin* ]]     && return 1
  [[ $1 =~ ^/boot* ]]    && return 1
  [[ $1 =~ ^/etc* ]]     && return 1
  [[ $1 =~ ^/lib* ]]     && return 1
  [[ $1 =~ ^/lib64* ]]   && return 1
  [[ $1 =~ ^/proc* ]]    && return 1
  [[ $1 =~ ^/root* ]]    && return 1
  [[ $1 =~ ^/sbin* ]]    && return 1
  [[ $1 =~ ^/selinux* ]] && return 1
  [[ $1 =~ ^/sys* ]]     && return 1

  return 0
}

# -
#
# Default start handler
#
# Code: Yes
# Echo: No
kvStart() {
  kv.requireRoot

  kvCheckPaths

  local status

  status=$(kv.getStatus)

  if [[ "$status" == "$STATUS_RUNNING" ]] ; then
    kv.warn "Service already running"
    return $ACTION_ERROR
  fi

  local retcode retcode_post

  kvFixIfNotInStatus $STATUS_STOPPED

  if [[ -n "${kv_dout[start_pre]}" ]] ; then
    kvExecDefHandler "start" "pre" "$@"
  else
    kvExecDefHandler "start" "pre" "$@" &>> "${kv[output]}"
  fi

  retcode=$?

  [[ $retcode -ne $ACTION_OK ]] && return $retcode

  kv.showProcessMessage "Starting ${kv[prog_name]}"
  kvExecDefHandler "start" "" "$@" &>> "${kv[output]}"
  retcode=$?
  kv.showStatusMessage "$retcode"

  if [[ -n "${kv_dout[start_post]}" ]] ; then
    kvExecDefHandler "start" "post" "$@"
    retcode_post=$?
  else
    kvExecDefHandler "start" "post" "$@" &>> "${kv[output]}"
    retcode_post=$?
  fi

  [[ $retcode_post -ne $retcode && $retcode -eq $ACTION_OK ]] && retcode=$retcode_post

  if [[ $retcode -eq $ACTION_OK ]] ; then
    [[ -n "${kv[auto_lock]}" ]] && kv.createLock
    [[ -n "${kv[supervisor]}" ]] && kvExportSupervisorCron
    [[ -n "${kv[oom_adj]}" ]] && kv.setOOMScoreAdj
  fi

  if [[ -n "${kv[auto_actions_log]}" ]] ; then
    if [[ $retcode -eq $ACTION_OK ]] ; then
      kv.log "${kv[real_user]} started service"
    else
      kv.log "${kv[real_user]} tried to start service but the action failed"
    fi
  fi

  return $retcode
}

# -
#
# Default stop handler
#
# Code: Yes
# Echo: No
kvStop() {
  kv.requireRoot

  kvCheckPaths

  local status

  status=$(kv.getStatus)

  if [[ "$status" == "$STATUS_STOPPED" ]] ; then
    kv.warn "Service already stopped"
    return $ACTION_ERROR
  fi

  local retcode retcode_post

  kvFixIfNotInStatus $STATUS_RUNNING

  if [[ -n "${kv_dout[stop_pre]}" ]] ; then
    kvExecDefHandler "stop" "pre" "$@"
  else
    kvExecDefHandler "stop" "pre" "$@" &>> "${kv[output]}"
  fi

  retcode=$?

  [[ $retcode -ne $ACTION_OK ]] && return $retcode

  kv_pid=$(kv.getPID)

  kv.showProcessMessage "Stopping ${kv[prog_name]}"
  kvExecDefHandler "stop" "" "$@" &>> "${kv[output]}"
  retcode=$?
  kv.showStatusMessage "$retcode"

  if [[ -n "${kv_dout[stop_post]}" ]] ; then
    kvExecDefHandler "stop" "post" "$@"
    retcode_post=$?
  else
    kvExecDefHandler "stop" "post" "$@" &>> "${kv[output]}"
    retcode_post=$?
  fi

  [[ $retcode_post -ne $retcode && $retcode -eq $ACTION_OK ]] && retcode=$retcode_post

  if [[ $retcode -eq $ACTION_OK || $retcode -eq $ACTION_FORCED ]] ; then
    [[ -n "${kv[auto_lock]}" ]] && kv.removeLock
    [[ -n "${kv[supervisor]}" ]] && kvRemoveSupervisorCron
    [[ -f "${kv[pid_file]}" ]] && kv.removePIDFile
  fi

  if [[ -n "${kv[auto_actions_log]}" ]] ; then
    if [[ $retcode -eq $ACTION_OK || $retcode -eq $ACTION_FORCED ]] ; then
      kv.log "${kv[real_user]} stopped service"
    else
      kv.log "${kv[real_user]} tried to stop service but the action failed"
    fi
  fi

  return $retcode
}

# -
#
# Default restart handler
#
# Code: Yes
# Echo: No
kvRestart() {
  kv.requireRoot

  kvCheckPaths

  if ! kv.statusIs "$STATUS_STOPPED" ; then
    kvFixIfNotInStatus "$STATUS_RUNNING"
  fi

  if ! kv.statusIs "$STATUS_RUNNING" ; then
    kv.warn "The service must be running for this command to have any effect"
    return $ACTION_ERROR
  fi

  if [[ -n "${kv_dout[restart_pre]}" ]] ; then
    kvExecDefHandler "restart" "pre" "$@"
  else
    kvExecDefHandler "restart" "pre" "$@" &>> "${kv[output]}"
  fi

  kvExecDefHandler "restart" "" "$@" &>> "${kv[output]}"

  [[ $? -ne $ACTION_OK ]] && return $ACTION_ERROR

  kvStop

  [[ ${kv[delay_restart]} -ne 0 ]] && sleep "${kv[delay_restart]}"

  kvStart

  [[ $? -ne $ACTION_OK ]] && return $ACTION_ERROR

  if [[ -n "${kv_dout[restart_post]}" ]] ; then
    kvExecDefHandler "restart" "post" "$@"
  else
    kvExecDefHandler "restart" "post" "$@" &>> "${kv[output]}"
  fi
}

# -
#
# Execute handler for some command
#
# 1: Command name (String)
# 2: Handler type pre/post (String) [Optional]
#
# Code: Yes
# Echo: No
kvExecDefHandler() {
  local comm="$1"
  local htype="$2"

  local handler

  case $htype in
    "pre")  handler="${kv_handler_pre["$comm"]}" ;;
    "post") handler="${kv_handler_post["$comm"]}" ;;
    *)      handler="${kv_handler["$comm"]}" ;;
  esac

  if [[ -z "$handler" ]] ; then
    return $ACTION_OK
  fi

  if ! kvIsFuncExist "$handler" ; then
    return $ACTION_OK
  fi

  shift 2

  $handler "$@"

  return $?
}

# -
#
# Method fixes some problems if service is not in defined status
#
# 1: Status code (Number)
#
# Code: No
# Echo: No
kvFixIfNotInStatus() {
  local status="$1"

  if [[ "$status" != "$status" ]] ; then
    case $status in
      $STATUS_DEAD_WITH_PID)
        kv.warn "Service is dead but PID file [${kv[pid_file]}] exists" ;;
      $STATUS_DEAD_WITH_LOCK)
        kv.warn "Service is dead but lock file [${kv[lock_file]}] exists" ;;
      $STATUS_NO_PID)
        kv.warn "Service is running but PID file is not found" ;;
      $STATUS_NO_LOCK)
        kv.warn "Service is running but lock file is not found" ;;
      $STATUS_BROKEN)
        kv.warn "Something wrong (but anyway we will try to fix it automatically)" ;;
    esac

    kvFixProblems
  fi
}

# -
#
# Default handler for status command
#
# Code: Yes
# Echo: No
kvStatus() {
  local status pid

  status=$(kv.getStatus)

  if [[ "$status" == "$STATUS_RUNNING" ]] ; then
    pid=$(kv.getPID)
    kv.show "Service ${kv[prog_name]} ${CL_DARK}[${pid}]${CL_NORM} is ${CL_GREEN}running${CL_NORM}"
    return $ACTION_OK
  fi

  if [[ "$status" == "$STATUS_STOPPED" ]] ; then
    kv.show "Service ${kv[prog_name]} is ${CL_YELLOW}stopped${CL_NORM}"
    return 3
  fi

  case $status in
    $STATUS_DEAD_WITH_PID)
      kv.warn "Service ${kv[prog_name]} is dead but PID file [${kv[pid_file]}] exists" ;;
    $STATUS_DEAD_WITH_LOCK)
      kv.warn "Service ${kv[prog_name]} is dead but lock file [${kv[lock_file]}] exists" ;;
    $STATUS_NO_PID)
      kv.warn "Service ${kv[prog_name]} running but PID file is not found" ;;
    $STATUS_NO_LOCK)
      kv.warn "Service ${kv[prog_name]} running but lock file is not found" ;;
    $STATUS_BROKEN)
      kv.warn "Something wrong with ${kv[prog_name]} (but anyway we will try to fix it automatically)" ;;
  esac

  if kv.isRoot ; then
    kvFixProblems
  fi

  return $ACTION_ERROR
}

# -
#
# Default handler for help command
#
# Code: No
# Echo: No
kvUsage() {
  [[ -n ${kv[auto_info]} ]] && kvAppendBasicCommands

  local comm_list comm comm_args comm_desc comm_ctl comm_tld

  comm_list="${kv_comm[*]}"
  comm_list="${comm_list// /|}"

  kv.show ""
  kv.show "${CL_BOLD}Usage:${CL_NORM} service ${CL_YELLOW}${kv[script]}${CL_NORM} ${CL_GREEN}{$comm_list}${CL_NORM}"
  kv.show ""

  local comm_tl=0

  for comm in "${kv_comm[@]}" ; do
    comm_args="${kv_args["$comm"]}"
    comm_ctl=$((${#comm} + ${#comm_args}))

    [[ $comm_ctl -gt $comm_tl ]] && comm_tl="$comm_ctl"
  done

  comm_tl=$(( comm_tl + HELP_SEPARATOR_LENGTH ))

  for comm in "${kv_comm[@]}" ; do
    comm_desc="${kv_desc["$comm"]}"
    comm_args="${kv_args["$comm"]}"

    if [[ -n "$comm_args" ]] ; then
      comm_tld=$(( comm_tl - ${#comm} - 1))
      printf "  ${CL_GREEN}%-${#comm}s${CL_NORM} ${CL_GREY}%-${comm_tld}s${CL_NORM} %s\n" "$comm" "$comm_args" "$comm_desc"
    else
      printf "  ${CL_GREEN}%-${comm_tl}s${CL_NORM} %s\n" "$comm" "$comm_desc"
    fi
  done

  kv.show ""
}

# -
#
# Append stack of default commands
#
# Code: No
# Echo: No
kvAppendBasicCommands() {
  local kv_comm_old=${kv_comm[*]}

  unset kv_comm

  [[ -z "${kv_desc[start]}" ]] && kv.addCommand "start" "Start ${kv[prog_name]} service"
  [[ -z "${kv_desc[stop]}" ]] && kv.addCommand "stop" "Stop ${kv[prog_name]} service"
  [[ -z "${kv_desc[restart]}" ]] && kv.addCommand "restart" "Restart (stop+start) ${kv[prog_name]} service"
  [[ -z "${kv_desc[status]}" ]] && kv.addCommand "status" "Show current status of ${kv[prog_name]}"

  # shellcheck disable=SC2206
  kv_comm+=($kv_comm_old)

  [[ -z "${kv_desc[help]}" ]] && kv.addCommand "help" "Show this information"
}

# -
#
# The method returns 0 if the method with given name exists
#
# 1: Method name (String)
#
# Code: Yes
# Echo: No
kvIsFuncExist() {
  local func="$1"

  [[ -z "$func" ]] && return 1

  declare -f "$func" &> /dev/null

  return $?
}

# -
#
# Method fixes some problems with a script (lock or PID files with stopped service,
# deleted lock or PID file with working service, etc...)
#
# Code: No
# Echo: No
kvFixProblems() {
  if ! kv.isRoot ; then
    show "You must have superuser privileges for fixing problems automatically"
    return
  fi

  local status pid

  while : ; do
    status=$(kv.getStatus)

    if [[ $status -eq $STATUS_DEAD_WITH_PID ]] ; then
      kv.showm "Removing PID file: "

      rm -f "${kv[pid_file]}" &> /dev/null
      kv.showStatusMessage $?

      continue
    elif [[ $status -eq $STATUS_DEAD_WITH_LOCK ]] ; then
      kv.showm "Removing lock file: "

      rm -f "${kv[lock_file]}" &> /dev/null
      kv.showStatusMessage $?

      continue
    elif [[ $status -eq $STATUS_NO_PID ]] ; then
      kv.showm "Restoring PID file: "

      pid=$(kv.findPID)
      [[ -z "$pid" ]] && kv.showStatusMessage $ACTION_ERROR && return

      if ! echo "$pid" 1> "${kv[pid_file]}" 2> /dev/null ; then
        kv.showStatusMessage $ACTION_ERROR
        return
      fi

      if [[ -n "${kv[user]}" ]] ; then
        chown "${kv[user]}:" "${kv[pid_file]}"
        kv.showStatusMessage $?
      else
        kv.showStatusMessage $ACTION_OK
      fi

      continue
    elif [[ $status -eq $STATUS_NO_LOCK ]] ; then
      kv.showm "Restoring lock file: "

      touch "${kv[lock_file]}" &> /dev/null
      kv.showStatusMessage $?

      continue
    elif [[ $status -eq $STATUS_BROKEN ]] ; then
      kv.showm "Fixing problems: "

      [[ -f "${kv[pid_file]}" && ! -s "${kv[pid_file]}" ]] && rm -f "${kv[pid_file]}" &> /dev/null

      pid=$(kv.findPID)

      [[ -n "$pid" ]] && echo "$pid" 1> "${kv[pid_file]}" 2> /dev/null
      [[ -n "${kv[user]}" ]] && chown "${kv[user]}:" "${kv[pid_file]}" &> /dev/null

      kv.show "POSSIBLE FIXED" $YELLOW

      continue
    fi

    break
  done
}

# -
#
# Method export supervisor cron task
#
# Code: No
# Echo: No
kvExportSupervisorCron() {
  echo "* * * * * root $SUPERVISOR ${kv[prog_name]} ${kv[pid_file]} ${kv[lock_file]}" > "$CRON_DIR/${kv[prog_name]}-supervisor"
  chmod 644 "$CRON_DIR/${kv[prog_name]}-supervisor"
}

# -
#
# Method remove supervisor cron task
#
# Code: No
# Echo: No
kvRemoveSupervisorCron() {
  if [[ -e "$CRON_DIR/${kv[prog_name]}-supervisor" ]] ; then
    rm -f "$CRON_DIR/${kv[prog_name]}-supervisor"
  fi
}

# -
#
# The method creates a temporary file for service output
#
# Code: No
# Echo: No
kvMkOutput() {
  [[ "${kv[output]}" == "/dev/null" ]] && return 1

  kv[output]=$(mktemp "$TMP_TEMPLATE")
}

# -
#
# Method copy data from temporary file to log or logger
#
# Code: No
# Echo: No
kvSendOutputToLogger() {
  if [[ -e ${kv[output]} && -s ${kv[output]} ]] ; then
    if [[ -n "${kv[log]}" ]] ; then
      cat "${kv[output]}" 1> "${kv[log]}" 2>/dev/null
    else
      logger -i -t "${kv[prog_name]}(kaosv)" < "${kv[output]}"
    fi
  fi

  if [[ -e ${kv[output]} ]] ; then
    rm -f "${kv[output]}" &> /dev/null
  fi
}

# -
#
# Get system boot date as timestamp
#
# Code: No
# Echo: Boot date (Number)
kvGetBootTimestamp() {
  local upt now

  upt=$(cut -f1 -d"." < "/proc/uptime")
  now=$(date +%s)

  echo $(( now - upt ))
}

# -
#
# Get file modification timestamp
#
# 1: File (String)
#
# Code: No
# Echo: Modification timestamp (Number)
kvGetFileModDate() {
  stat -c '%Y' "$1" 2> /dev/null
}

# -
#
# Check if system supports colored output
#
# Code: Yes
# Echo: No
kvIsColorsSupported() {
  if [[ -n "$NO_COLOR" ]] ; then
    return 1
  fi

  if [[ -z "${kv[use_colors]}" ]] ; then
    return 1
  fi

  if kv.isInstalled "tput" ; then
    if [[ $(tput colors 2>/dev/null) -lt 16 ]] ; then
      return 1
    fi
  fi

  return 0
}

###############################################################################
