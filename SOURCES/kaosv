#!/usr/bin/env bash

# KAOSv is bash lib for SysV init scripts.
# 
# This lib can be used as replacement for default /etc/init.d/functions lib.
# 

if [[ "$BASH" == "/bin/sh" ]] ; then
  bash $0 $@
  exit $?
fi

###############################################################################

# Current version of KAOSv
KV_VERSION="2.8.0"

###############################################################################

# Code for reset prev color codes
NORM=0
# Code for bold text
BOLD=1
# Code for underline text
UNLN=4
# Code for red color
RED=31
# Code for green color
GREEN=32
# Code for yellow color
BROWN=33
# Code for blue color
BLUE=34
# Code for magenta color
MAG=35
# Code for cyan color
CYAN=36
# Code for grey color
GREY=37

if [[ $(consoletype) == "pty" ]] ; then
  CL_NORM="\e[${NORM}m"
  CL_BOLD="\e[${BOLD}m"
  CL_UNLN="\e[${UNLN}m"
  CL_RED="\e[${RED}m"
  CL_GREEN="\e[${GREEN}m"
  CL_BROWN="\e[${BROWN}m"
  CL_BLUE="\e[${BLUE}m"
  CL_MAG="\e[${MAG}m"
  CL_CYAN="\e[${CYAN}m"
  CL_GREY="\e[${GREY}m"
  CL_BL_RED="\e[${RED};1m"
  CL_BL_GREEN="\e[${GREEN};1m"
  CL_BL_BROWN="\e[${BROWN};1m"
  CL_BL_BLUE="\e[${BLUE};1m"
  CL_BL_MAG="\e[${MAG};1m"
  CL_BL_CYAN="\e[${CYAN};1m"
  CL_BL_GREY="\e[${GREY};1m"
  CL_UL_RED="\e[${RED};4m"
  CL_UL_GREEN="\e[${GREEN};4m"
  CL_UL_BROWN="\e[${BROWN};4m"
  CL_UL_BLUE="\e[${BLUE};4m"
  CL_UL_MAG="\e[${MAG};4m"
  CL_UL_CYAN="\e[${CYAN};4m"
  CL_UL_GREY="\e[${GREY};4m"
  CL_BG_RED="\e[${RED};7m"
  CL_BG_GREEN="\e[${GREEN};7m"
  CL_BG_BROWN="\e[${BROWN};7m"
  CL_BG_BLUE="\e[${BLUE};7m"
  CL_BG_MAG="\e[${MAG};7m"
  CL_BG_CYAN="\e[${CYAN};7m"
  CL_BG_GREY="\e[${GREY};7m"

  COLORS_ALLOWED=true
fi

###############################################################################

umask 022

export PATH="/sbin:/usr/sbin:/bin:/usr/bin"

###############################################################################

# Current user id (Number)
USER_ID=$(id -u)

# Status code for working service
STATUS_WORKS=1
# Status code for stopped service
STATUS_STOPPED=2
# Status code for broken service
STATUS_BROKEN=3
# Status code for situation when service doesn't works, but pid file is exist
STATUS_DEAD_WITH_PID=4
# Status code for situation when service doesn't works, but lock file is exist 
STATUS_DEAD_WITH_LOCK=5
# Status code for situation when service works, but pid file is not exist
STATUS_NO_PID=6
# Status code for situation when service works, but lock file is not exist
STATUS_NO_LOCK=7

# Status for action performed without errors 
ACTION_OK=0
# Status for action with some errors
ACTION_ERROR=1
# Status for action which was forced
ACTION_FORCED=2

# Code for HUP signal
SIGNAL_HUP=1
# Code for INT signal
SIGNAL_INT=2
# Code for QUIT signal
SIGNAL_QUIT=3
# Code for ILL signal
SIGNAL_ILL=4
# Code for TRAP signal
SIGNAL_TRAP=5
# Code for ABRT signal
SIGNAL_ABRT=6
# Code for BUS signal
SIGNAL_BUS=7
# Code for FPE signal
SIGNAL_FPE=8
# Code for KILL signal
SIGNAL_KILL=9
# Code for USR1 signal
SIGNAL_USR1=10
# Code for SEGV signal
SIGNAL_SEGV=11
# Code for USR2 signal
SIGNAL_USR2=12
# Code for PIPE signal
SIGNAL_PIPE=13
# Code for ALRM signal
SIGNAL_ALRM=14
# Code for TERM signal
SIGNAL_TERM=15
# Code for STKFLT signal
SIGNAL_STKFLT=16
# Code for CHLD signal
SIGNAL_CHLD=17
# Code for CONT signal
SIGNAL_CONT=18
# Code for STOP signal
SIGNAL_STOP=19
# Code for TSTP signal
SIGNAL_TSTP=20
# Code for TTIN signal
SIGNAL_TTIN=21
# Code for TTOU signal
SIGNAL_TTOU=22
# Code for URG signal
SIGNAL_URG=23
# Code for XCPU signal
SIGNAL_XCPU=24
# Code for XFSZ signal
SIGNAL_XFSZ=25
# Code for VTALRM signal
SIGNAL_VTALRM=26
# Code for PROF signal
SIGNAL_PROF=27
# Code for WINCH signal
SIGNAL_WINCH=28
# Code for IO signal
SIGNAL_IO=29
# Code for PWR signal
SIGNAL_PWR=30
# Code for SYS signal
SIGNAL_SYS=31

# This constant can be used as argument in kv.setOOMScoreAdj for disabling OOM Killer
OOM_DISABLE="-1000"

HANDLER_PRE="pre"
HANDLER_POST="post"

LIMITS="/etc/security/limits.conf /etc/security/limits.d/*.conf"
SYSCONFIG_DIR="/etc/sysconfig"

HELP_SEPARATOR_LENGTH=4

TMP_TEMPLATE="/tmp/kaosv.XXXXXXXX"

CRON_DIR="/etc/cron.d"

SUPERVISOR="/usr/local/share/kaosv/supervisor"

###############################################################################

kv_comm=()

declare -A kv_desc
declare -A kv_func
declare -A kv_handler
declare -A kv_handler_pre
declare -A kv_handler_post
declare -A kv_insec
declare -A kv_alias
declare -A kv_args
declare -A kv_dout
declare -A kv

# Program name used as base for help/paths/files generation
kv[prog_name]=""

# Pattern used for searching service process in process tree
kv[search_pattern]=""

# Path to lock file
kv[lock_file]=""

# Path to pid file
kv[pid_file]=""

# Service user
kv[user]=""

# Service dir
kv[dir]=""

# Automatically create pid file while service demonization (Boolean)
kv[auto_pid]=true

# Automatically create lock file while service demonization (Boolean)
kv[auto_lock]=true

# Automatically generete help command content (Boolean)
kv[auto_info]=true

# Automatically log all actions (start/stop/restart/etc...) (Boolean)
kv[auto_actions_log]=""

# Automatically search pid if pid file is not exist (Boolean)
kv[auto_pid_search]=true

# Time in seconds for service start
kv[delay_start]=15

# Time in seconds for service stop
kv[delay_stop]=30

# Delay between start and stop
kv[delay_restart]=0

# Path to pid dir
kv[pid_dir]=/var/run

# Path to lock dir
kv[lock_dir]=/var/lock/subsys

# Path to log
kv[log]=""

kv[output]=""

# Core limit (Number)
kv[core_limit]=0

# File soft/hard limit (String)
kv[file_limit]=""

# Processes soft/hard limit (String)
kv[proc_limit]=""

# Nice level (Number)
kv[nice]=""

# io nice prefs (String)
kv[ionice]=""

# OOM Score adjust (Number)
kv[oom_adj]=""

# Use supervisor feature (Boolean)
kv[supervisor]=""

# Script name (String)
kv[script]=$(readlink -f "$0" | xargs -n1 basename)
# Real user name (search real user name over sudo) (String)
kv[real_user]=$(who -m | cut -f1 -d" " | egrep "[a-z]" || echo "root")

###############################################################################

kv_pid="" # Pid cache

###############################################################################

# Start command processing
#
# *: All arguments passed to service script
#
# Code: No
# Echo: No
# 
# Example:
# kv.go $@
kv.go() {
  [[ $# -eq 0 || "$1" == "help" ]] && kvUsage && kv.exit $ACTION_OK

  kvPrepare

  trap kv.exit SIGINT SIGTERM

  local comm="$1"

  shift

  [[ -n "${kv_alias["$comm"]}" ]] && comm="${kv_alias["$comm"]}"

  kvMkOutput
  kvRegisterBasicCommands

  local comm_handler="${kv_func["$comm"]}"

  if ! kvIsFuncExist "$comm_handler" ; then
    kv.error "Can't find handler for command <$comm>." $ACTION_ERROR
  fi

  if [[ -z ${kv_insec["$comm"]} ]] ; then
    kv.requireRoot
    kvCheckPaths
  fi

  if [[ -n "${kv[auto_actions_log]}" ]] ; then
    kv.log "${kv[real_user]} executed command $comm."
  fi

  $comm_handler $@

  kv.exit $?
}

###############################################################################

# Check required version of kaosv
#
# 1: Version (String)
#
# Code: No
# Echo: No
# 
# Example:
# kv.require "2.7"
kv.require() {
  [[ $# -eq 0 ]] && return

  local cur_ver=(${KV_VERSION//./ })
  local req_ver=(${1//./ })

  for i in $(seq 0 2) ; do
    if [[ "${req_ver[$i]}" == "" ]] ; then
      return
    fi

    if [[ ${req_ver[$i]} -gt ${cur_ver[$i]} ]] ; then
      kv.error "Init script requires kaosv $1 or higher"
    fi
  done
}

# Add command
#
# 1: Command name (String)
# 2: Command description (String)
# 3: Handler function name (String)
# 4: Do not require root for execute (Boolean) [Optional]
#
# Code: No
# Echo: No
# 
# Example:
# kv.AddCommand "check" "Check config value" "myCheckFunc" true
# kv.AddCommand "kill" "Kill connections" "myKillFunc"
kv.addCommand() {
  local comm="$1"
  local desc="$2"
  local func="$3"
  local insecure="$4"

  kv_comm+=("$comm")

  kv_desc["$comm"]="$desc"
  kv_func["$comm"]="$func"
  kv_insec["$comm"]="$insecure"
}

# Add handler for start/stop/restart/status command
#
# 1: Command name (String)
# 2: Handler (String)
# 3: Type of handler (pre/post/default) (String)
#
# Code: No
# Echo: No
kv.addHandler() {
  local comm="$1"
  local handler="$2"
  local htype="$3"

  case $htype in
    $HANDLER_PRE)  kv_handler_pre["$comm"]="$handler" ;;
    $HANDLER_POST) kv_handler_post["$comm"]="$handler" ;;
    *)             kv_handler["$comm"]="$handler" ;;
  esac
}

# Add alias for command
#
# 1: Command name (String)
# 2: Alias name (String)
#
# Code: No
# Echo: No
# 
# Example:
# kv.addCommandAlias "test" "check"
kv.addCommandAlias() {
  local comm="$1"
  local als="$2"

  kv_alias["$als"]="$comm"
}

# Add some vars for command showed in info
#
# 1: Command (String)
# *: Vars (String)
#
# Code: No
# Echo: No
# 
# Example:
# kv.addCommandArgs "stop" "force"
kv.addCommandArgs() {
  local comm="$1"

  shift

  local arg args

  for arg in $@ ; do
    vars="$args $arg"
  done

  kv_args["$comm"]="${vars:1:9999}"
}

# -
# Alias for kv.addCommandArgs for compatibility with
# earlier versions
kv.addCommandVars() {
  kv.addCommandArgs $@
  return $?
}

# Disable automatic output redirection
#
# 1: Handler name (String)
# 2: Type of handler (pre/post/default) (String)
#
# Code: No
# Echo: No
kv.disableOutputRedirect() {
  local handler="$1"
  local htype="$2"

  if [[ -n "$htype" ]] ; then
    kv_dout["${handler}_${htype}"]=true
  else
    kv_dout["$handler"]=true
  fi
}

# Eval values from sysconfig
#
# 1: Name of sysconfig file (String) [Optional]
#
# Code: No
# Echo: No
kv.readSysconfig() {
  local conf="${1:-${kv[prog_name]}}"
  local strict="$2"

  if [[ -n "$strict" ]] ; then
    [[ -z "$conf" ]] && kv.error "Can't read sysconfig file - config name is not defined." && return 1

    [[ ! -f $SYSCONFIG_DIR/$conf ]] && kv.error "Can't read sysconfig file - file <$SYSCONFIG_DIR/$conf> is not exist." && return 1
    [[ ! -r $SYSCONFIG_DIR/$conf ]] && kv.error "Can't read sysconfig file - file <$SYSCONFIG_DIR/$conf> is not readable." && return 1
  fi

  [[ ! -r $SYSCONFIG_DIR/$conf ]] && return 0

  local ar=$(stat -c "%A" $SYSCONFIG_DIR/$conf)
  local oi=$(stat -c "%U" $SYSCONFIG_DIR/$conf)

  if [[ "${ar:8:1}" != "-" ]] ; then
    kv.error "Can't read sysconfig file - unsecure access rights." && return 1
  fi

  if [[ "$oi" != "root" ]] ; then
    kv.error "Can't read sysconfig file - owner is not root." && return 1
  fi

  source $SYSCONFIG_DIR/$conf
}

# Exec command
#
# *: Command (String)
#
# Code: Exit code (Boolean)
# Echo: No
# 
# Example:
# local status=$(kv.run "/bin/echo" "1234" "ABCD")
# 
# if [[ $status -eq 0 ]] ; then
#   return $ACTION_OK
# else
#   return $ACTION_ERROR
# fi
kv.run() {
  [[ $# -eq 0 ]] && kv.log "You can't execute kv.run without args." && return 1

  local cmd_user="${kv[user]}"

  [[ -z "$cmd_user" ]] && cmd_user="root"

  kv.runAs "$cmd_user" $@

  return $?
}

# Exec command as some user
#
# 1: User (String)
# *: Command
#
# Code: Exit code (Boolean)
# Echo: No
# 
# Example:
# kv.runAs "someuser" "/bin/echo" "1234" "ABCD"
# 
# if [[ $? -eq 0 ]] ; then
#   return $ACTION_OK
# else
#   return $ACTION_ERROR
# fi
kv.runAs() {
  [[ $# -le 1 ]] && kv.log "You can't execute kv.runAs without args." && return 1

  local cmd_user="$1"

  shift

  if [[ -n "$cmd_user" ]] ; then
    if ! kv.hasUser "$cmd_user" ; then
      echo "Can't execute command - user $cmd_user is not exist on the system." >> ${kv[output]}
      return $ACTION_ERROR
    fi
  fi

  local cl_limit cl_nice

  cl_limit=$(kvGetLimitsCmd)
  cl_nice=$(kvGetNicesCmd)

  local args="$*"

  if [[ "$cmd_user" == "root" ]] ; then
    $cl_nice /bin/bash -c "$cl_limit; $args" &>> ${kv[output]}
  else
    $cl_nice runuser -s /bin/bash $cmd_user -c "$cl_limit; $args" &>> ${kv[output]}
  fi

  return $?
}

# Daemonize process
#
# 1: Binary (String)
# *: Command arguments
#
# Code: Return code (Boolean)
# Echo: No
# 
# Example:
# kv.daemonize "/usr/bin/daemon" "-d" "-p 80" "-v"
# 
# if [[ $? -eq 0 ]] ; then
#   return $ACTION_OK
# else
#   return $ACTION_ERROR
# fi
kv.daemonize() {
  [[ $# -eq 0 ]] && kv.log "You can't execute kv.daemonize without args." && return 1

  local bin="$1"

  [[ "${bin:0:1}" != "/" || ! -x $bin ]] && kv.log "First argument in kv.daemonize must be absolute path to executable file." && return 1

  local args=""

  [[ -n "${kv[auto_pid]}" ]] && args="$args -p ${kv[pid_file]}"
  [[ -n "${kv[user]}" ]] && args="$args -u ${kv[user]}"
  [[ -n "${kv[dir]}" ]] && args="$args -c ${kv[dir]}"
  [[ -n "${kv[log]}" ]] && args="$args -a -o ${kv[log]} -e ${kv[log]}"

  args="$args $*"

  local cl_limit cl_nice

  cl_limit=$(kvGetLimitsCmd)
  cl_nice=$(kvGetNicesCmd)

  /bin/bash -c "$cl_limit; $cl_nice daemonize $args" &>> ${kv[output]}

  return $?
}

# Execute default start handler
#
# *: Any arguments
#
# Code: Return code (Boolean)
# Echo: No
kv.start() {
  kvStart $@
  return $?
}

# Execute default stop handler
#
# *: Any arguments
#
# Code: Return code (Boolean)
# Echo: No
kv.stop() {
  kvStop $@
  return $?
}

# Execute default restart handler
#
# *: Any arguments
#
# Code: Return code (Boolean)
# Echo: No
kv.restart() {
  kvRestart $@
  return $?
}

# Execute default status handler
#
# *: Any arguments
#
# Code: Return code (Boolean)
# Echo: No
kv.status() {
  kvStatus $@
  return $?
}

# Execute default usage handler
#
# *: Any arguments
#
# Code: Return code (Boolean)
# Echo: No
kv.usage() {
  kvUsage $@
  return $?
}

# Require root privileges, if user is not
# a root, exit with error status
#
# Code: No
# Echo: No
kv.requireRoot() {
  if ! kv.isRoot ; then
    kv.error "You must have root privileges to use this command." $ACTION_ERROR
  fi
}

# Return 0 if service in defined status
#
# 1: Status (Number) [Optional]
#
# Code: Boolean
# Echo: No
kv.statusIs() {
  local nstatus="$1"
  local cstatus=$(kv.getStatus)

  [[ "$cstatus" == "$nstatus" ]] && return 0 || return 1
}

# Get status for service
#
# Code: No
# Echo: Status code (Number)
kv.getStatus() {
  if [[ -f ${kv[pid_file]} && -r ${kv[pid_file]} ]] ; then
    local pid=$(kv.getPid)

    [[ -z "$pid" ]] && echo $STATUS_BROKEN && return

    if kv.isProcExist "$pid" ; then
      if [[ ! -f ${kv[lock_file]} ]] ; then
        echo $STATUS_NO_LOCK && return
      else
        echo $STATUS_WORKS && return
      fi
    else
      echo $STATUS_DEAD_WITH_PID && return
    fi
  else
    local pid=$(kv.findPid)

    if [[ -n "$pid" ]] ; then
      if [[ ! -f ${kv[pid_file]} ]] ; then
        echo $STATUS_NO_PID && return
      else
        echo $STATUS_BROKEN && return
      fi
    else
      if [[ -f ${kv[lock_file]} ]] ; then
        echo $STATUS_DEAD_WITH_LOCK && return
      else
        echo $STATUS_STOPPED && return
      fi
    fi
  fi
}

# Get or find pid
#
# Code: No
# Echo: Pid (Number)
# 
# Example:
# local pid=$(kv.getPid)
# kv.sendSignal $pid
kv.getPid() {
  if [[ -f ${kv[pid_file]} && -r ${kv[pid_file]} ]] ; then
    cat ${kv[pid_file]}
  else
    kv.findPid
  fi
}

# Find pid for service
#
# 1: Search pattern (String) [Optional]
#
# Code: No
# Echo: Pid (Number)
# 
# Example:
# local pid=$(kv.findPid "service -c /etc/config.conf")
kv.findPid() {
  [[ -z "${kv[auto_pid_search]}" && -z "$1" ]] && return
  ps aux | egrep -v "grep|service|init\.d" | egrep "${1:-${kv[search_pattern]}}" | tr -s " " | cut -f2 -d" " | head -1
}

# Show message about action in progress
#
# 1: Message (String)
#
# Code: No
# Echo: No
# 
# Example:
# kv.showProcessMessage "Generating data"
# kv.showStatusMessage $ACTION_OK
kv.showProcessMessage() {
  kv.showm "$1: " $BOLD
}

# Show status of previus action
#
# 1: Status code (Number)
#
# Code: No
# Echo: No
# 
# Example:
# kv.showProcessMessage "Generating data"
# kv.showStatusMessage $ACTION_OK
kv.showStatusMessage() {
  case $1 in
    $ACTION_OK)     kv.show "${CL_GREEN}OK${CL_NORM}" ;;
    $ACTION_ERROR)  kv.show "${CL_RED}ERROR${CL_NORM}" ;;
    $ACTION_FORCED) kv.show "${CL_BROWN}FORCED${CL_NORM}" ;;
  esac

  return $1
}

# Get status of starting service
#
# 1: Path to pid file (String) [Optional]
# 2: Don't check process status (Boolean) [Optional]
#
# Code: Status (Boolean)
# Echo: No
# 
# Example:
# if ! kv.getStartStatus ; then
#   kv.error "Can't start service"
# fi
kv.getStartStatus() {
  local cpid_file="${1:-${kv[pid_file]}}"
  local no_check_proc="$2"

  local i

  for i in $(seq 1 ${kv[delay_start]:-15}) ; do
    if [[ -f $cpid_file && -r $cpid_file ]] ; then
      [[ -n "$no_check_proc" ]] && return $ACTION_OK

      local pid=$(head -1 $cpid_file)

      if kv.isProcExist "$pid" ; then
        return $ACTION_OK
      fi
    fi

    sleep 1
  done

  return $ACTION_ERROR
}

# Get status of stopping service
#
# 1: Pid (Number) [Optional]
#
# Code: Status (Boolean)
# Echo: No
# 
# Example:
# if kv.getStopStatus $pid ; then
#   return $ACTION_OK
# else
#   kv.killProcess $pid 
#   return $ACTION_FORCED
# fi
kv.getStopStatus() {
  local pid="${1:-$kv_pid}"

  [[ -z "$pid" ]] && return $ACTION_ERROR

  local i

  for i in $(seq 1 ${kv[delay_stop]:-30}) ; do
    if ! kv.isProcExist "$pid" ; then
      return $ACTION_OK
    fi

    sleep 1
  done

  return $ACTION_ERROR
}

# Kill service process
#
# 1: Pid (Number) [Optional]
#
# Code: No
# Echo: No
kv.killProcess() {
  local pid="$1"

  [[ -z "$pid" ]] && pid=$(kv.findPid)
  [[ -z "$pid" ]] && return 1

  kill -KILL $pid >/dev/null 2>&1

  kv.removeLock
  kv.removePid
}

# Return 0 if process with specified pid exist
#
# 1: Pid (Number)
#
# Code: Yes
# Echo: No
# 
# Example:
# if kv.isProcExist 12345 ; then
#   kv.error "Process with pid 12345 is not exist"
# fi
kv.isProcExist() {
  [[ -d /proc/$1 ]] && return 0 || return 1
}

# Return 0 if user exists on the system
#
# 1: Username (String)
#
# Code: Yes
# Echo: No
# 
# Example:
# if ! kv.hasUser "serviceuser" ; then
#   kv.error "User serviceuser is not exist!"
# fi
kv.hasUser() {
  [[ $(egrep "^$1:" /etc/passwd) ]] && return 0 || return 1
}

# Check that port is bound (occupied by another process)
#
# 1: Port (Number)
#
# Code: Yes
# Echo: No
# 
# Example:
# if kv.isBoundPort 8080 ; then
#   kv.error "Port 8080 is bound"
# fi
kv.isBoundPort() {
  [[ $# -eq 0 ]] && return 1
  [[ $(netstat -antu | tr -s " " | cut -f4 -d" " | sed 's/:.*:/:/g' | cut -f2 -d":" | egrep "^$1$" | head -1) ]] && return 0 || return 1
}

# Return 0 if specified apps installed on the system
#
# 1: Apps (List)
#
# Code: Yes
# Echo: No
# 
# Example:
# if ! kv.isInstalled "java" "nc" ; then
#   kv.error "Java and netcat is not installed"
# fi
kv.isInstalled() {
  local app

  for app in $@ ; do
    type -p $app &> /dev/null
    [[ $? -ne 0 ]] && return 1
  done

  return 0
}

# Send signal to service
#
# 1: Signal (String)
# 2: Pid (Number) [Optional]
#
# Code: Yes
# Echo: No
# 
# Example:
# if ! kv.sendSignal $SIGNAL_QUIT ; then
#   kv.error "Can't send signal"
# fi
kv.sendSignal() {
  [[ $# -eq 0 ]] && return 1

  local signal="$1"

  [[ -n "$2" ]] && local pid="$2" || local pid=$(kv.getPid)
  [[ -z "$pid" || -z "$signal" ]] && return 1

  kill -${signal} $pid >/dev/null 2>&1
}

# Set the adjustment level for the Out of memory (OOM) killer
#
# 1: Adjustment level (Number) [Optional]
# 2: Process pid (Number) [Optional]
#
# Code: No
# Echo: No
# 
# Example:
# kv.setOOMScoreAdj "-1000" "12345"
# kv.setOOMScoreAdj "$OOM_DISABLE"
kv.setOOMScoreAdj() {
  local adj="${1:-${kv[oom_adj]}}"
  local pid="$2"

  [[ -z "$adj" ]] && return 1
  [[ -z "$pid" ]] && pid=$(kv.getPid)
  [[ -z "$pid" ]] && return 1

  echo "$adj" > /proc/$pid/oom_score_adj
}

# Check SE Linux
#
# Code: Boolean
# Echo: No
kv.checkSELinux() {
  if [[ $(getenforce) == "Enforcing" ]] ; then
    kv.show ""
    kv.show "Can't start ${kv[prog_name]}. It looks like SELinux blocks port binding." $RED
    kv.show "To resolve this problem change SELinux mode to ${CL_BOLD}Permissive${CL_NORM}"
    kv.show "by ${CL_BOLD}sudo setenforce 0${CL_NORM} command or configure SELinux context."

    return $ACTION_ERROR
  fi
}

###############################################################################

# Check is user root
#
# Code: Yes
# Echo: No
# 
# Example:
# if ! kv.isRoot ; then
#   kv.error "This action require root privileges!"
# fi
kv.isRoot() {
  [[ "$USER_ID" != "0" ]] && return 1 || return 0
}

# Create lock file
#
# Code: No
# Echo: No
kv.createLock() {
  touch ${kv[lock_file]} &> /dev/null
}

# Remove lock file
#
# Code: No
# Echo: No
kv.removeLock() {
  rm -rf ${kv[lock_file]} &> /dev/null
}

# Return 0 if lock file exist
#
# Code: Yes
# Echo: No
# 
# Example:
# if kv.hasLock ; then
#   echo "Lock file exist!"
# fi
kv.hasLock() {
  [[ -f ${kv[lock_file]} ]] && return 1 || return 0
}

# Create pid file
#
# 1: Pid (Number)
#
# Code: No
# Echo: No
# 
# Example:
# kv.createPid 12345
kv.createPid() {
  echo "$1" > ${kv[pid_file]}
}

# Remove pid file
#
# Code: No
# Echo: No
kv.removePid() {
  rm -f ${kv[pid_file]} &> /dev/null
}

# Exit from the script
#
# 1: Error code (Number) [Optional]
#
# Code: No
# Echo: No
# 
# Example:
# kv.exit
# kv.exit 1
kv.exit() {
  kvSendOutputToLogger

  rm -f ${TMP_TEMPLATE//X/}* &> /dev/null

  exit ${1:-0}
}

###############################################################################

# Disable all colors in output
#
# Code: No
# Echo: No
kv.disableColors() {
  unset NORM BOLD UNLN RED GREEN BROWN BLUE MAG CYAN GREY
  unset CL_NORM CL_BOLD CL_UNLN CL_RED CL_GREEN CL_BROWN CL_BLUE CL_MAG CL_CYAN CL_GREY
  unset CL_BL_RED CL_BL_GREEN CL_BL_BROWN CL_BL_BLUE CL_BL_MAG CL_BL_CYAN CL_BL_GREY
  unset CL_UL_RED CL_UL_GREEN CL_UL_BROWN CL_UL_BLUE CL_UL_MAG CL_UL_CYAN CL_UL_GREY
  unset CL_BG_RED CL_BG_GREEN CL_BG_BROWN CL_BG_BLUE CL_BG_MAG CL_BG_CYAN CL_BG_GREY
}

# Show error message
#
# 1: Message (String)
# 2: Error code (Number) [Optional]
#
# Code: No
# Echo: No
# 
# Example:
# kv.error "My error message"
# kv.error "My error message" 10
kv.error() {
  kv.show "$1" $RED

  if [[ -n "$2" ]] ; then
    kv.exit ${2:-1}
  fi
}

# Show warning message
#
# 1: Message (String)
#
# Code: No
# 
# Example:
# kv.warn "My warning message"
kv.warn() {
  kv.show "$@" $BROWN
}

# Show message
#
# 1: Message (String)
# 2: Color (String) [Optional]
#
# Code: No
# Echo: No
# 
# Example:
# show "Signal sended"
# show "Can't do some action" $RED
kv.show() {
  if [[ -n "$2" && -n "$COLORS_ALLOWED" ]] ; then
    echo -e "\e["$2"m"$1"${CL_NORM}"
  else
    echo -e "$@"
  fi
}

# Show message without new line symbol
#
# 1: Message (String)
# 2: Color (String) [Optional]
#
# Code: No
# Echo: No
kv.showm() {
  local message

  if [[ -n "$2" && -n "$COLORS_ALLOWED" ]] ; then
    message=$(echo "\e["$2"m"$1"${CL_NORM}")
  else
    message="$@"
  fi

  printf "$message"
}

# Show version of kaosv
#
# Code: No
# Echo: Version (String)
kv.version() {
  echo "$KV_VERSION"
}

# Restore SELinux context
#
# *: Files
#
# Code: No
# Echo: No
# 
# Example:
# kv.restoreSEContext "/path/to/file"
kv.restoreSEContext() {
  local target

  for target in $@ ; do
    [[ -x /sbin/restorecon ]] && /sbin/restorecon $target
  done
}

# Read property from file
#
# 1: File (String)
# 2: Property name (String)
# 3: Delimiter (String) [Optional]
#
# Code: No
# Echo: Property value (String)
# 
# Example:
# local port=$(kv.readProperty "/path/to/my.conf" "port")
# local host=$(kv.readProperty "/path/to/my.conf" "host" ":")
kv.readProperty() {
  local file="$1"
  local prop="$2"
  local delm="${3:-=}"

  [[ -z "$file" || -z "$prop" ]] && echo "" && return 1

  grep -E "^([ ]{0,})${prop}" "$file" | awk -F${delm} '{print $2}' | sed 's/^ *//'
}

# Add message to logfile or logger
#
# 1: Message (String)
#
# Code: No
# Echo: No
# 
# Example:
# kv.log "My very important message"
kv.log() {
  local message="$@"

  if [[ -n "${kv[log]}" ]] ; then
    echo "$message" >> ${kv[log]}
  else
    echo "$message" | logger -i -t "${kv[prog_name]}(kaosv)"
  fi
}

###############################################################################

# -
#
# Prepare script for start
#
# Code: No
# Echo: No
kvPrepare() {
  if [[ -z "${kv[prog_name]}" ]] ; then
    kv.error "Can't execute this init script. Please define prog_name value first." $ACTION_ERROR
  fi

  if [[ -n "${kv[auto_pid_search]}" && -z "${kv[search_pattern]}" ]] ; then
    kv.error "Can't execute this init script. Please define search_pattern value first." $ACTION_ERROR
  fi

  if ! kvIsWellPath "${kv[pid_dir]}" ; then
    kv.error "Can't execute this init script. Property pid_dir contains wrong path (${kv[pid_dir]})." $ACTION_ERROR
  fi

  if ! kvIsWellPath "${kv[lock_dir]}" ; then
    kv.error "Can't execute this init script. Property lock_dir contains wrong path (${kv[lock_dir]})." $ACTION_ERROR
  fi

  if [[ -n "${kv[output]}" ]] ; then
    if ! kvIsWellPath "${kv[output]}" ; then
      kv.error "Can't execute this init script. Property output contains wrong path (${kv[output]})." $ACTION_ERROR
    fi
  fi

  if [[ -n "${kv[dir]}" ]] ; then
    if ! kvIsWellPath "${kv[dir]}" ; then
      kv.error "Can't execute this init script. Property dir contains wrong path (${kv[dir]})." $ACTION_ERROR
    fi

    if [[ ! -d ${kv[dir]} ]] ; then
      kv.error "Can't execute this init script. Service directory <${kv[dir]}> is not exist." $ACTION_ERROR
    fi
  fi

  if [[ -n "${kv[user]}" ]] ; then
    if ! kv.hasUser "${kv[user]}" ; then
      kv.error "User <${kv[user]}> is not exist." $ACTION_ERROR
    fi
  fi

  [[ -z "${kv[pid_file]}" ]] && kv[pid_file]=${kv[pid_dir]}/${kv[script]}.pid
  [[ -z "${kv[lock_file]}" ]] && kv[lock_file]=${kv[lock_dir]}/${kv[script]}

  if [[ -n "${kv[log]}" ]] ; then
    local log_dir=$(dirname ${kv[log]})

    if ! kvIsWellPath "$log_dir" ; then
      kv.error "Can't execute this init script. Property log contains wrong path (${kv[log]})." $ACTION_ERROR
    fi

    if [[ ! -d $log_dir ]] ; then
      kv.error "Log file directory <$log_dir> is not exist." $ACTION_ERROR
    fi

    if [[ -f ${kv[log]} && ! -w ${kv[log]} ]] ; then
      kv.error "Log file is not writable." $ACTION_ERROR
    fi
  fi

  kv[pid_dir]=$(dirname ${kv[pid_file]})
  kv[lock_dir]=$(dirname ${kv[lock_file]})

  if ! kvIsWellPath "${kv[pid_dir]}" ; then
    kv.error "Can't use pid dir <${kv[pid_dir]}>." $ACTION_ERROR
  fi

  if ! kvIsWellPath "${kv[lock_dir]}" ; then
    kv.error "Can't use lock dir <${kv[lock_dir]}>." $ACTION_ERROR
  fi
}

# -
#
# Register basic command (start, stop, restart, status, help)
#
# Code: No
# Echo: No
kvRegisterBasicCommands() {
  [[ -z "${kv_func[start]}" ]]   && kv_func[start]="kvStart"
  [[ -z "${kv_func[stop]}" ]]    && kv_func[stop]="kvStop"
  [[ -z "${kv_func[restart]}" ]] && kv_func[restart]="kvRestart"
  [[ -z "${kv_func[status]}" ]]  && kv_func[status]="kvStatus"
  [[ -z "${kv_func[help]}" ]]    && kv_func[help]="kvUsage"
}

# -
#
# Method return ulimit command for setting limits
#
# Code: No
# Echo: Command (String)
kvGetLimitsCmd() {
  local result nproc nofile s_nproc s_nofile h_nproc h_nofile

  nproc="${kv[proc_limit]}"
  nofile="${kv[file_limit]}"

  if [[ -n "$nproc" ]] ; then
    s_nproc="${nproc%:*}"
    h_nproc="${nproc#*:}"
  fi

  if [[ -n "$nofile" ]] ; then
    s_nofile="${nofile%:*}"
    h_nofile="${nofile#*:}"
  fi

  if [[ -n "${kv[user]}" ]] ; then
    local np=$(kvGetUserLimit "${kv[user]}" "nproc")
    local nf=$(kvGetUserLimit "${kv[user]}" "nofile")

    if [[ -n "$np" ]] ; then
      s_nproc="${np%:*}"
      h_nproc="${np#*:}"
    fi

    if [[ -n "$nf" ]] ; then
      s_nofile="${nf%:*}"
      h_nofile="${nf#*:}"
    fi
  fi

  result="ulimit -S -c ${kv[core_limit]} &>/dev/null"

  if [[ -n "${h_nproc}${s_nproc}" ]] ; then
    [[ -n "$h_nproc" ]] && result="$result; ulimit -H -u $h_nproc &>/dev/null"
    [[ -n "$s_nproc" ]] && result="$result; ulimit -S -u $s_nproc &>/dev/null"
  fi

  if [[ -n "${h_nofile}${s_nofile}" ]] ; then
    [[ -n "$h_nofile" ]] && result="$result; ulimit -H -n $h_nofile &>/dev/null"
    [[ -n "$s_nofile" ]] && result="$result; ulimit -S -n $s_nofile &>/dev/null"
  fi

  echo "$result"
}

# -
#
# Method return soft and hard limits
#
# Code: No
# Echo: Soft and hard limit (String)
kvGetUserLimit() {
  local user="$1"
  local item="$2"

  local rec reca soft hard

  while read rec ; do
    reca=($rec)

    if [[ "${reca[2]}" == "$item" ]] ; then
      if [[ "${reca[1]}" == "soft" ]] ; then
        soft="${reca[3]}"
      elif [[ "${reca[1]}" == "hard" ]] ; then
        hard="${reca[3]}"
      fi
    fi
  done < <(cat $LIMITS | tr "\t" " " | tr -s " " | grep -v "#" | grep "$user ")

  [[ -n "$soft" || -n "$hard" ]] && echo "$soft:$hard"
}

# -
#
# Method return nice command
#
# Code: No
# Echo: Command (String)
kvGetNicesCmd() {
  local result nlevel nclass nclassdata ion

  if [[ -n "${kv[nice]}" ]] ; then
    result="nice -n ${kv[nice]}"
  fi

  if [[ -n "${kv[ionice]}" ]] ; then
    ion="${kv[ionice]}"

    nclass="${ion%:*}"
    nclassdata="${ion#*:}"

    result="$result ionice"

    [[ -n "$nclass" ]] && result="$result -c $nclass"
    [[ -n "$nclassdata" ]] && result="$result -n $nclassdata"

  fi

  echo $result
}

# -
#
# Method checks used paths and exits if some path is not safety
#
# Code: No
# Echo: No
kvCheckPaths() {
  if [[ ! -e ${kv[pid_dir]} ]] ; then
    if kv.isRoot ; then
      mkdir -p ${kv[pid_dir]} &> /dev/null
    fi
  fi

  if [[ "${kv[pid_dir]}" != "/var/run" && "${kv[pid_dir]}" != "/var/run/" ]] ; then
    if [[ -n "${kv[user]}" && "${kv[user]}" != $(kvGetOwner "${kv[pid_dir]}") ]] ; then
      if kv.isRoot ; then
        if ! kv.hasUser "${kv[user]}" ; then
          kv.error "Can't change owner for pid directory <${kv[pid_dir]}> - user <${kv[user]}> not exist on system." $ACTION_ERROR
        fi

        chown ${kv[user]} ${kv[pid_dir]}
      fi
    fi
  fi

  if [[ ! -e ${kv[lock_dir]} ]] ; then
    if kv.isRoot ; then
      mkdir -p ${kv[lock_dir]} &> /dev/null
    fi
  fi

  if [[ ! -w ${kv[lock_dir]} ]] ; then
    kv.error "Lock dir <${kv[lock_dir]}> is not writable." $ACTION_ERROR
  fi
   if [[ ! -w ${kv[pid_dir]} ]] ; then
    kv.error "Pid dir <${kv[pid_dir]}> is not writable." $ACTION_ERROR
  fi
}

# -
# 
# Method return owner of file
#
# 1: File (String)
#
# Code: No
# Echo: Owner name (String)
kvGetOwner() {
  [[ ! -f $1 ]] && return
  stat -c "%U" $1
}

# -
#
# Method check what given path is well formated and safe
#
# 1: Path (String) 
#
# Code: Yes
# Echo: No
kvIsWellPath() {
  case $1 in
    "")         return 1 ;;
    "/")        return 1 ;;
    "/home")    return 1 ;;
    "/home/")   return 1 ;;
    "/usr")     return 1 ;;
    "/usr/")    return 1 ;;
    "/var")     return 1 ;;
    "/var/")    return 1 ;;
  esac

  [[ $1 =~ ^/bin* ]]     && return 1
  [[ $1 =~ ^/boot* ]]    && return 1
  [[ $1 =~ ^/etc* ]]     && return 1
  [[ $1 =~ ^/lib* ]]     && return 1
  [[ $1 =~ ^/lib64* ]]   && return 1
  [[ $1 =~ ^/proc* ]]    && return 1
  [[ $1 =~ ^/root* ]]    && return 1
  [[ $1 =~ ^/sbin* ]]    && return 1
  [[ $1 =~ ^/selinux* ]] && return 1
  [[ $1 =~ ^/sys* ]]     && return 1

  return 0
}

# -
#
# Default start handler
#
# Code: Yes
# Echo: No
kvStart() {
  kv.requireRoot

  kvCheckPaths

  local status=$(kv.getStatus)

  if [[ "$status" == "$STATUS_WORKS" ]] ; then
    kv.warn "Service already works."
    return $ACTION_ERROR
  fi

  local retcode

  kvFixIfNotInStatus $STATUS_STOPPED

  if [[ -n "${kv_dout[start_pre]}" ]] ; then
    kvExecDefHandler "start" "pre" $@
  else
    kvExecDefHandler "start" "pre" $@ &>> ${kv[output]}
  fi

  retcode=$?

  [[ $retcode -ne 0 ]] && return $retcode

  kv.showProcessMessage "Starting ${kv[prog_name]}"
  kvExecDefHandler "start" "" $@ &>> ${kv[output]}
  retcode=$?
  kv.showStatusMessage "$retcode"

  if [[ ${kv_dout[start_post]} ]] ; then
    kvExecDefHandler "start" "post" $@
  else
    kvExecDefHandler "start" "post" $@ &>> ${kv[output]}
  fi

  [[ $? -ne $retcode && $retcode -eq 0 ]] && retcode=$?

  if [[ $retcode -eq 0 ]] ; then
    [[ -n "${kv[auto_lock]}" ]] && kv.createLock
    [[ -n "${kv[supervisor]}" ]] && kvExportSupervisorCron
    [[ -n "${kv[oom_adj]}" ]] && kv.setOOMScoreAdj
  fi

  if [[ -n "${kv[auto_actions_log]}" ]] ; then
    if [[ $retcode -eq 0 ]] ; then
      kv.log "${kv[real_user]} started service."
    else
      kv.log "${kv[real_user]} tried to start service but action failed."
    fi
  fi

  return $retcode
}

# -
# 
# Default stop handler
#
# Code: Yes
# Echo: No
kvStop() {
  kv.requireRoot

  kvCheckPaths

  local status=$(kv.getStatus)

  if [[ "$status" == "$STATUS_STOPPED" ]] ; then
    kv.warn "Service already stopped."
    return $ACTION_ERROR
  fi

  local retcode

  kvFixIfNotInStatus $STATUS_WORKS

  if [[ -n "${kv_dout[stop_pre]}" ]] ; then
    kvExecDefHandler "stop" "pre" $@
  else
    kvExecDefHandler "stop" "pre" $@ &>> ${kv[output]}
  fi

  retcode=$?

  [[ $retcode -ne 0 ]] && return $retcode

  kv_pid=$(kv.getPid)

  kv.showProcessMessage "Stopping ${kv[prog_name]}"
  kvExecDefHandler "stop" "" $@ &>> ${kv[output]}
  retcode=$?
  kv.showStatusMessage "$retcode"

  if [[ -n "${kv_dout[stop_post]}" ]] ; then
    kvExecDefHandler "stop" "post" $@
  else
    kvExecDefHandler "stop" "post" $@ &>> ${kv[output]}
  fi

  [[ $? -ne $retcode && $retcode -eq 0 ]] && retcode=$?

  if [[ $retcode -eq 0 ]] ; then
    [[ -n "${kv[auto_lock]}" ]] && kv.removeLock
    [[ -n "${kv[supervisor]}" ]] && kvRemoveSupervisorCron
  fi

  [[ $retcode -eq 0 && -f ${kv[pid_file]} ]] && kv.removePid

  if [[ -n "${kv[auto_actions_log]}" ]] ; then
    if [[ $retcode -eq 0 ]] ; then
      kv.log "${kv[real_user]} stopped service."
    else
      kv.log "${kv[real_user]} tried to stop service but action failed."
    fi
  fi

  return $retcode
}

# -
# 
# Default restart handler
#
# Code: Yes
# Echo: No
kvRestart() {
  kv.requireRoot

  kvCheckPaths

  if [[ -n "${kv_dout[restart_pre]}" ]] ; then
    kvExecDefHandler "restart" "pre" $@
  else
    kvExecDefHandler "restart" "pre" $@ &>> ${kv[output]}
  fi

  kvExecDefHandler "restart" "" $@ &>> ${kv[output]}

  [[ $? -ne 0 ]] && return $ACTION_ERROR

  kvStop

  [[ ${kv[delay_restart]} -ne 0 ]] && sleep ${kv[delay_restart]}

  kvStart

  [[ $? -ne 0 ]] && return $ACTION_ERROR

  if [[ -n "${kv_dout[restart_post]}" ]] ; then
    kvExecDefHandler "restart" "post" $@
  else
    kvExecDefHandler "restart" "post" $@ &>> ${kv[output]}
  fi
}

# -
# 
# Execute handler for some command
#
# 1: Command name (String)
# 2: Handler type pre/post (String) [Optional]
#
# Code: Yes
# Echo: No
kvExecDefHandler() {
  local comm="$1"
  local htype="$2"

  local handler

  case $htype in
    "pre")  handler="${kv_handler_pre["$comm"]}" ;;
    "post") handler="${kv_handler_post["$comm"]}" ;;
    *)      handler="${kv_handler["$comm"]}" ;;
  esac

  if [[ -z "$handler" ]] ; then
    return $ACTION_OK
  fi

  if ! kvIsFuncExist "$handler" ; then
    return $ACTION_OK
  fi

  shift 2

  $handler $@

  return $?
}

# -
# 
# Method fix some problems if service is not in defined status
#
# 1: Status code (Number)
#
# Code: No
# Echo: No
kvFixIfNotInStatus() {
  local status="$1"

  if [[ "$status" != "$status" ]] ; then
    case $status in
      $STATUS_DEAD_WITH_PID)
        kv.warn "Service is dead but pid file [${kv[pid_file]}] exists." ;;
      $STATUS_DEAD_WITH_LOCK)
        kv.warn "Service is dead but lock file [${kv[lock_file]}] exists." ;;
      $STATUS_NO_PID)
        kv.warn "Service works but pid file is not found." ;;
      $STATUS_NO_LOCK)
        kv.warn "Service works but lock file is not found." ;;
      $STATUS_BROKEN)
        kv.warn "Something wrong (but anyway we will try fix it automatically)." ;;
    esac

    kvFixProblems
  fi
}

# -
# 
# Default handler for status command
#
# Code: Yes
# Echo: No
kvStatus() {
  kvCheckPaths

  local status=$(kv.getStatus)

  if [[ "$status" == "$STATUS_WORKS" ]] ; then
    local pid=$(kv.getPid)
    kv.show "Service ${kv[prog_name]} ${CL_GREY}[${pid}]${CL_NORM} is ${CL_GREEN}works${CL_NORM}."
    return $ACTION_OK
  fi

  if [[ "$status" == "$STATUS_STOPPED" ]] ; then
    kv.show "Service ${kv[prog_name]} is ${CL_BROWN}stopped${CL_NORM}."
    return 3
  fi

  case $status in
    $STATUS_DEAD_WITH_PID)
      kv.warn "Service is dead but pid file [${kv[pid_file]}] exists." ;;
    $STATUS_DEAD_WITH_LOCK)
      kv.warn "Service is dead but lock file [${kv[lock_file]}] exists." ;;
    $STATUS_NO_PID)
      kv.warn "Service works but pid file is not found." ;;
    $STATUS_NO_LOCK)
      kv.warn "Service works but lock file is not found." ;;
    $STATUS_BROKEN)
      kv.warn "Something wrong (but anyway we will try fix it automatically)." ;;
  esac

  if kv.isRoot ; then
    kvFixProblems
  fi

  return $ACTION_ERROR
}

# -
#
# Default handler for help command 
#
# Code: No
# Echo: No
kvUsage() {
  [[ -n ${kv[auto_info]} ]] && kvAppendBasicCommands

  local comm_list=$(echo "${kv_comm[@]}" | sed 's/ /|/g')

  kv.show ""
  kv.show "${CL_BOLD}Usage:${CL_NORM} service ${CL_BROWN}${kv[script]}${CL_NORM} ${CL_GREEN}{$comm_list}${CL_NORM}"
  kv.show ""

  local comm comm_args comm_desc comm_ctl

  local comm_tl=0

  for comm in ${kv_comm[@]} ; do
    comm_args="${kv_args["$comm"]}"
    comm_ctl=$((${#comm} + ${#comm_args}))

    [[ $comm_ctl -gt $comm_tl ]] && comm_tl=$comm_ctl
  done

  comm_tl=$(($comm_tl + $HELP_SEPARATOR_LENGTH))

  for comm in ${kv_comm[@]} ; do
    comm_desc="${kv_desc["$comm"]}"
    comm_args="${kv_args["$comm"]}"

    if [[ -n "$comm_args" ]] ; then
      local comm_tld=$(($comm_tl - ${#comm} - 1))
      printf "  ${CL_GREEN}%-${#comm}s${CL_NORM} ${CL_GREY}%-${comm_tld}s${CL_NORM} %s\n" "$comm" "$comm_args" "$comm_desc"
    else
      printf "  ${CL_GREEN}%-${comm_tl}s${CL_NORM} %s\n" "$comm" "$comm_desc"
    fi
  done

  kv.show ""
}

# -
# 
# Append stack of default commands
#
# Code: No
# Echo: No
kvAppendBasicCommands() {
  local kv_comm_old=${kv_comm[@]}

  unset kv_comm

  [[ -z "${kv_desc[start]}" ]] && kv.addCommand "start" "Start ${kv[prog_name]} service"
  [[ -z "${kv_desc[stop]}" ]] && kv.addCommand "stop" "Stop ${kv[prog_name]} service"
  [[ -z "${kv_desc[restart]}" ]] && kv.addCommand "restart" "Restart (stop+start) ${kv[prog_name]} service"
  [[ -z "${kv_desc[status]}" ]] && kv.addCommand "status" "Show current status of ${kv[prog_name]}"

  kv_comm+=(${kv_comm_old[@]})

  [[ -z "${kv_desc[help]}" ]] && kv.addCommand "help" "Show this information"
}

# -
#
# Method return 0 if method with given name is exist
#
# 1: Method name (String)
#
# Code: Yes
# Echo: No
kvIsFuncExist() {
  local func="$1"

  [[ -z "$func" ]] && return 1

  declare -f $func &> /dev/null
  
  return $?
}

# -
# 
# Method fix some problems with script (lock or pid files with stopped service,
# deleted lock or pid file with working service, etc...)
#
# Code: No
# Echo: No
kvFixProblems() {
  if ! kv.isRoot ; then
    show "You must have superuser privileges for fixing problems automatically."
    return
  fi

  while : ; do
    local status=$(kv.getStatus)

    if [[ $status -eq $STATUS_DEAD_WITH_PID ]] ; then
      kv.showm "Removing pid file: "

      rm -f ${kv[pid_file]} &> /dev/null
      kv.showStatusMessage $?

      continue
    elif [[ $status -eq $STATUS_DEAD_WITH_LOCK ]] ; then
      kv.showm "Removing lock file: "

      rm -f ${kv[lock_file]} &> /dev/null
      kv.showStatusMessage $?

      continue
    elif [[ $status -eq $STATUS_NO_PID ]] ; then
      kv.showm "Restoring pid file: "

      local pid=$(kv.findPid)
      [[ -z "$pid" ]] && kv.showStatusMessage $ACTION_ERROR && return

      echo "$pid" > ${kv[pid_file]} 2> /dev/null
      [[ $? -ne 0 ]] && kv.showStatusMessage $ACTION_ERROR && return

      if [[ -n "${kv[user]}" ]] ; then
        chown ${kv[user]}: ${kv[pid_file]}
        kv.showStatusMessage $?
      else
        kv.showStatusMessage $ACTION_OK
      fi

      continue
    elif [[ $status -eq $STATUS_NO_LOCK ]] ; then
      kv.showm "Restoring lock file: "

      touch ${kv[lock_file]} &> /dev/null
      kv.showStatusMessage $?

      continue
    elif [[ $status -eq $STATUS_BROKEN ]] ; then
      kv.showm "Fixing problems: "

      [[ -f ${kv[pid_file]} && ! -s ${kv[pid_file]} ]] && rm -f ${kv[pid_file]} &> /dev/null

      local pid=$(kv.findPid)

      [[ -n "$pid" ]] && echo "$pid" > ${kv[pid_file]} &> /dev/null
      [[ -n "${kv[user]}" ]] && chown ${kv[user]}: ${kv[pid_file]} &> /dev/null

      kv.show "POSSIBLE FIXED" $BROWN

      continue
    fi

    break
  done
}

# -
#
# Method export supervisor cron task
#
# Code: No
# Echo: No
kvExportSupervisorCron() {
  echo "* * * * * root $SUPERVISOR ${kv[prog_name]} ${kv[pid_file]} ${kv[lock_file]}" > $CRON_DIR/${kv[prog_name]}-supervisor
  chmod 644 $CRON_DIR/${kv[prog_name]}-supervisor
}

# -
#
# Method remove  supervisor cron task
#
# Code: No
# Echo: No
kvRemoveSupervisorCron() {
  if [[ -e $CRON_DIR/${kv[prog_name]}-supervisor ]] ; then
    rm -f $CRON_DIR/${kv[prog_name]}-supervisor
  fi
}

# -
#
# Method create temporary file for service output
#
# Code: No
# Echo: No
kvMkOutput() {
  [[ "${kv[output]}" == "/dev/null" ]] && return 1
  [[ -e ${kv[output]} && -w ${kv[output]} ]] && return 0

  kv[output]=$(mktemp $TMP_TEMPLATE)
}

# - 
#
# Method copy data from temporary file to log or logger
#
# Code: No
# Echo: No
kvSendOutputToLogger() {
  if [[ -s ${kv[output]} ]] ; then
    if [[ -n "${kv[log]}" ]] ; then
      cat ${kv[output]} >> ${kv[log]}
    else
      cat ${kv[output]} | logger -i -t "${kv[prog_name]}(kaosv)"
    fi

    echo -n > ${kv[output]}
  fi
}

###############################################################################
